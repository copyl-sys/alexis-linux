@* TritJS: Enhanced Ternary Scientific Calculator with Robust Error Control.
This document presents \.{TritJS}, a library for ternary (base-3) arithmetic and scientific operations,
adapted from a JavaScript module into C. It supports basic arithmetic (addition, subtraction, multiplication,
division), scientific functions (exponentiation, square roots, base-3 logarithms, sine, cosine, tangent,
factorials), and constants like π, all operating on trit arrays (digits in $\{0, 1, 2\}$). Key features include
fractional trit support via `TritFloat`, arbitrary-precision arithmetic via `TritBigInt`, accurate trigonometric
scaling using a ternary π, an interactive CLI, and comprehensive error handling.

Errors are managed with a `TritError` enum, ensuring graceful failure and detailed feedback to the user.

@c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

@*1 Error Handling.
A custom enum standardizes error reporting across all functions.

@d TritError int
@d TRIT_OK 0
@d TRIT_ERR_MEM 1        /* Memory allocation failed */
@d TRIT_ERR_INPUT 2      /* Invalid input (e.g., non-trit digit) */
@d TRIT_ERR_DIV_ZERO 3   /* Division by zero */
@d TRIT_ERR_OVERFLOW 4   /* Arithmetic overflow or too large */
@d TRIT_ERR_UNDEFINED 5  /* Operation undefined (e.g., log(0)) */

const char* trit_error_str(TritError err) {
    switch (err) {
        case TRIT_OK: return "No error";
        case TRIT_ERR_MEM: return "Memory allocation failed";
        case TRIT_ERR_INPUT: return "Invalid input";
        case TRIT_ERR_DIV_ZERO: return "Division by zero";
        case TRIT_ERR_OVERFLOW: return "Overflow or value too large";
        case TRIT_ERR_UNDEFINED: return "Operation undefined";
        default: return "Unknown error";
    }
}

@*1 Data Structures and Constants.
Structures for trits, big integers, floats, and division results.

@d TRIT_MAX 3
typedef int Trit;
typedef struct {
    Trit* digits;
    int len;
} TritBigInt;
typedef struct {
    Trit* integer;
    Trit* fraction;
    int i_len;
    int f_len;
} TritFloat;
typedef struct {
    Trit* quotient;
    Trit* remainder;
    int q_len;
    int r_len;
} TritDivResult;

@*1 Helper Functions.
Utilities with error handling for conversions, arithmetic, and structure management.

@<Conversion Functions@>
@<Arithmetic Helpers@>
@<Big Integer Helpers@>
@<Float Helpers@>

@ Conversions with error propagation.
@c
@<Conversion Functions@>=
TritError trits_to_binary(Trit* trits, int len, unsigned long* result) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT;
    *result = 0;
    for (int i = 0; i < len; i++) {
        if (trits[i] > 2) return TRIT_ERR_INPUT;
        if (*result > ULONG_MAX >> 2) return TRIT_ERR_OVERFLOW;
        *result = (*result << 2) | trits[i];
    }
    return TRIT_OK;
}

TritError binary_to_trits(unsigned long bin, int len, Trit** trits) {
    if (len <= 0) return TRIT_ERR_INPUT;
    *trits = (Trit*)malloc(len * sizeof(Trit));
    if (!*trits) return TRIT_ERR_MEM;
    for (int i = len - 1; i >= 0; i--) {
        (*trits)[i] = bin & 0x3;
        bin >>= 2;
    }
    return TRIT_OK;
}

@ Single-trit arithmetic (simple, no errors).
@c
@<Arithmetic Helpers@>=
typedef struct { Trit value; int carry; } TritSum;
TritSum trit_add(Trit a, Trit b) {
    int sum = a + b;
    return (TritSum){ sum % TRIT_MAX, sum / TRIT_MAX };
}

typedef struct { Trit value; int borrow; } TritDiff;
TritDiff trit_subtract(Trit a, Trit b) {
    int diff = a - b;
    if (diff >= 0) return (TritDiff){ diff, 0 };
    return (TritDiff){ (diff + TRIT_MAX) % TRIT_MAX, 1 };
}

typedef struct { Trit value; int carry; } TritProd;
TritProd trit_multiply(Trit a, Trit b) {
    int prod = a * b;
    return (TritProd){ prod % TRIT_MAX, prod / TRIT_MAX };
}

@ Big integer helpers with error checks.
@c
@<Big Integer Helpers@>=
TritError tritbig_from_trits(Trit* trits, int len, TritBigInt** bi) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT;
    *bi = (TritBigInt*)malloc(sizeof(TritBigInt));
    if (!*bi) return TRIT_ERR_MEM;
    (*bi)->digits = (Trit*)malloc(len * sizeof(Trit));
    if (!(*bi)->digits) {
        free(*bi);
        return TRIT_ERR_MEM;
    }
    memcpy((*bi)->digits, trits, len * sizeof(Trit));
    (*bi)->len = len;
    return TRIT_OK;
}

void tritbig_free(TritBigInt* bi) {
    if (bi) {
        free(bi->digits);
        free(bi);
    }
}

@ Float helpers with error handling.
@c
@<Float Helpers@>=
TritError tritfloat_from_bigint(TritBigInt* bi, TritFloat* tf) {
    if (!bi || bi->len <= 0) return TRIT_ERR_INPUT;
    tf->integer = (Trit*)malloc(bi->len * sizeof(Trit));
    if (!tf->integer) return TRIT_ERR_MEM;
    memcpy(tf->integer, bi->digits, bi->len * sizeof(Trit));
    tf->i_len = bi->len;
    tf->fraction = NULL;
    tf->f_len = 0;
    return TRIT_OK;
}

void tritfloat_free(TritFloat tf) {
    free(tf.integer);
    if (tf.f_len > 0) free(tf.fraction);
}

@*1 Core Arithmetic Operations.
Arbitrary-precision operations with error handling.

@c
TritError tritjs_add_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    int max_len = (a->len > b->len) ? a->len : b->len;
    Trit* temp = (Trit*)malloc((max_len + 1) * sizeof(Trit));
    if (!temp) return TRIT_ERR_MEM;
    int carry = 0, pos = 0;

    for (int i = max_len - 1; i >= 0; i--) {
        Trit a_trit = (i < a->len) ? a->digits[i] : 0;
        Trit b_trit = (i < b->len) ? b->digits[i] : 0;
        TritSum sum = trit_add(a_trit + carry, b_trit);
        temp[max_len - pos] = sum.value;
        carry = sum.carry;
        pos++;
    }
    int result_len = carry ? max_len + 1 : max_len;
    if (!carry) memmove(temp, temp + 1, max_len * sizeof(Trit));
    else temp[0] = carry;
    TritError err = tritbig_from_trits(temp, result_len, result);
    free(temp);
    return err;
}

TritError tritjs_subtract_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    int max_len = (a->len > b->len) ? a->len : b->len;
    Trit* temp = (Trit*)malloc(max_len * sizeof(Trit));
    if (!temp) return TRIT_ERR_MEM;
    int borrow = 0;

    for (int i = max_len - 1; i >= 0; i--) {
        Trit a_trit = (i < a->len) ? a->digits[i] : 0;
        Trit b_trit = (i < b->len) ? b->digits[i] : 0;
        TritDiff diff = trit_subtract(a_trit - borrow, b_trit);
        temp[i] = diff.value;
        borrow = diff.borrow;
    }
    int start = 0;
    while (start < max_len - 1 && temp[start] == 0) start++;
    int result_len = max_len - start;
    TritError err = tritbig_from_trits(temp + start, result_len, result);
    free(temp);
    return err;
}

TritError tritjs_multiply_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    int max_len = a->len + b->len;
    Trit* temp = (Trit*)calloc(max_len, sizeof(Trit));
    if (!temp) return TRIT_ERR_MEM;
    for (int i = a->len - 1; i >= 0; i--) {
        int carry = 0;
        for (int j = b->len - 1; j >= 0; j--) {
            int pos = i + j + 1;
            TritProd prod = trit_multiply(a->digits[i], b->digits[j]);
            TritSum sum = trit_add(temp[pos] + carry, prod.value);
            temp[pos] = sum.value;
            carry = sum.carry + prod.carry;
        }
        if (carry) {
            int carry_pos = i;
            TritSum sum = trit_add(temp[carry_pos] + carry, 0);
            temp[carry_pos] = sum.value;
            if (sum.carry) {
                memmove(temp, temp + 1, max_len * sizeof(Trit));
                temp[0] = sum.carry;
                max_len++;
            }
        }
    }
    int start = 0;
    while (start < max_len - 1 && temp[start] == 0) start++;
    TritError err = tritbig_from_trits(temp + start, max_len - start, result);
    free(temp);
    return err;
}

TritError tritjs_divide_big(TritBigInt* a, TritBigInt* b, TritDivResult* result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    unsigned long a_bin, b_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    if ((err = trits_to_binary(b->digits, b->len, &b_bin)) != TRIT_OK) return err;
    if (b_bin == 0) return TRIT_ERR_DIV_ZERO;
    unsigned long quotient_bin = a_bin / b_bin;
    unsigned long remainder_bin = a_bin % b_bin;
    if ((err = binary_to_trits(quotient_bin, a->len, &result->quotient)) != TRIT_OK) return err;
    if ((err = binary_to_trits(remainder_bin, b->len, &result->remainder)) != TRIT_OK) {
        free(result->quotient);
        return err;
    }
    result->q_len = a->len;
    result->r_len = b->len;
    return TRIT_OK;
}

@*1 Scientific Operations.
Scientific functions with error handling, using `TritFloat` and `TritBigInt`.

@c
TritError tritjs_power_big(TritBigInt* base, TritBigInt* exp, TritBigInt** result) {
    if (!base || !exp) return TRIT_ERR_INPUT;
    TritError err;
    TritBigInt* res = NULL;
    if ((err = tritbig_from_trits((Trit[]){1}, 1, &res)) != TRIT_OK) return err;
    unsigned long exp_bin;
    if ((err = trits_to_binary(exp->digits, exp->len, &exp_bin)) != TRIT_OK) {
        tritbig_free(res);
        return err;
    }
    if (exp_bin > 1000) {  /* Arbitrary limit to prevent excessive computation */
        tritbig_free(res);
        return TRIT_ERR_OVERFLOW;
    }
    for (unsigned long i = 0; i < exp_bin; i++) {
        TritBigInt* temp;
        if ((err = tritjs_multiply_big(res, base, &temp)) != TRIT_OK) {
            tritbig_free(res);
            return err;
        }
        tritbig_free(res);
        res = temp;
    }
    *result = res;
    return TRIT_OK;
}

TritError tritjs_sqrt_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0) return TRIT_ERR_INPUT;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    double sqrt_val = sqrt((double)a_bin);
    unsigned long int_part = (unsigned long)sqrt_val;
    double frac_part = sqrt_val - int_part;
    if ((err = binary_to_trits(int_part, (a->len + 1) / 2, &result->integer)) != TRIT_OK) return err;
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        return err;
    }
    result->i_len = (a->len + 1) / 2;
    result->f_len = precision;
    return TRIT_OK;
}

TritError tritjs_log3_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0) return TRIT_ERR_INPUT;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    if (a_bin <= 0) return TRIT_ERR_UNDEFINED;
    double log_val = log((double)a_bin) / log(3.0);
    unsigned long int_part = (unsigned long)log_val;
    double frac_part = log_val - int_part;
    if ((err = binary_to_trits(int_part, a->len, &result->integer)) != TRIT_OK) return err;
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        return err;
    }
    result->i_len = a->len;
    result->f_len = precision;
    return TRIT_OK;
}

TritError tritjs_sin_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0) return TRIT_ERR_INPUT;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    int pi_len;
    Trit* pi;
    if ((err = tritjs_pi(&pi_len, &pi)) != TRIT_OK) return err;
    unsigned long pi_bin;
    if ((err = trits_to_binary(pi, pi_len, &pi_bin)) != TRIT_OK) {
        free(pi);
        return err;
    }
    double a_rad = (double)a_bin * M_PI / (double)pi_bin;
    double sin_val = sin(a_rad);
    int sign = (sin_val < 0) ? -1 : 1;
    double abs_val = fabs(sin_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;
    if ((err = binary_to_trits(int_part, 1, &result->integer)) != TRIT_OK) {
        free(pi);
        return err;
    }
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        free(pi);
        return err;
    }
    result->i_len = 1;
    result->f_len = precision;
    if (sign < 0) {
        Trit zero[] = {0};
        TritBigInt* zero_bi;
        TritBigInt* neg_int;
        if ((err = tritbig_from_trits(zero, 1, &zero_bi)) != TRIT_OK) {
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        if ((err = tritbig_from_trits(result->integer, result->i_len, &neg_int)) != TRIT_OK) {
            tritbig_free(zero_bi);
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        TritBigInt* temp;
        if ((err = tritjs_subtract_big(zero_bi, neg_int, &temp)) != TRIT_OK) {
            tritbig_free(zero_bi);
            tritbig_free(neg_int);
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        free(result->integer);
        result->integer = temp->digits;
        result->i_len = temp->len;
        tritbig_free(temp);
        tritbig_free(zero_bi);
        tritbig_free(neg_int);
    }
    free(pi);
    return TRIT_OK;
}

TritError tritjs_pi(int* len, Trit** pi) {
    Trit pi_val[] = {1, 0, 0, 1, 0, 2, 2, 1};  /* π ≈ 3.14159₁₀ ≈ 10.010221₃ */
    *len = 8;
    *pi = (Trit*)malloc(*len * sizeof(Trit));
    if (!*pi) return TRIT_ERR_MEM;
    memcpy(*pi, pi_val, *len * sizeof(Trit));
    return TRIT_OK;
}

@*1 Utility Functions.
String conversion with error handling.

@c
TritError tritjs_to_string(Trit* trits, int len, char** str) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT;
    *str = (char*)malloc(len + 1);
    if (!*str) return TRIT_ERR_MEM;
    for (int i = 0; i < len; i++) (*str)[i] = '0' + trits[i];
    (*str)[len] = '\0';
    return TRIT_OK;
}

TritError tritfloat_to_string(TritFloat tf, char** str) {
    if (!tf.integer || tf.i_len <= 0) return TRIT_ERR_INPUT;
    char* int_str;
    TritError err;
    if ((err = tritjs_to_string(tf.integer, tf.i_len, &int_str)) != TRIT_OK) return err;
    if (tf.f_len == 0) {
        *str = int_str;
        return TRIT_OK;
    }
    char* frac_str;
    if ((err = tritjs_to_string(tf.fraction, tf.f_len, &frac_str)) != TRIT_OK) {
        free(int_str);
        return err;
    }
    *str = (char*)malloc(tf.i_len + tf.f_len + 2);
    if (!*str) {
        free(int_str);
        free(frac_str);
        return TRIT_ERR_MEM;
    }
    sprintf(*str, "%s.%s", int_str, frac_str);
    free(int_str);
    free(frac_str);
    return TRIT_OK;
}

@*1 CLI Functions.
Interactive interface with robust error handling.

@c
TritError parse_trit_string(const char* str, TritBigInt** bi) {
    if (!str || strlen(str) == 0) return TRIT_ERR_INPUT;
    int len = strlen(str);
    Trit* trits = (Trit*)malloc(len * sizeof(Trit));
    if (!trits) return TRIT_ERR_MEM;
    for (int i = 0; i < len; i++) {
        if (str[i] < '0' || str[i] > '2') {
            free(trits);
            return TRIT_ERR_INPUT;
        }
        trits[i] = str[i] - '0';
    }
    TritError err = tritbig_from_trits(trits, len, bi);
    free(trits);
    return err;
}

void run_calculator() {
    char input[256];
    printf("TritJS Ternary Calculator (enter 'quit' to exit)\n");
    printf("Commands: add/sub/mul/div/pow/sqrt/log3/sin/cos/tan/fact/pi <arg1> [arg2]\n");
    while (1) {
        printf("> ");
        if (!fgets(input, 256, stdin)) break;
        input[strcspn(input, "\n")] = 0;
        if (strcmp(input, "quit") == 0) break;

        char op[10], arg1[20], arg2[20] = "";
        if (sscanf(input, "%9s %19s %19s", op, arg1, arg2) < 2) {
            printf("Error: Invalid command format\n");
            continue;
        }

        TritBigInt* a = NULL;
        TritBigInt* b = NULL;
        TritError err;

        if ((err = parse_trit_string(arg1, &a)) != TRIT_OK) {
            printf("Error with arg1: %s\n", trit_error_str(err));
            continue;
        }
        if (strlen(arg2) > 0 && (err = parse_trit_string(arg2, &b)) != TRIT_OK) {
            printf("Error with arg2: %s\n", trit_error_str(err));
            tritbig_free(a);
            continue;
        }

        if (strcmp(op, "add") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_add_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "sin") == 0) {
            TritFloat result;
            if ((err = tritjs_sin_float(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritfloat_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritfloat_free(result);
            }
        } else if (strcmp(op, "pi") == 0) {
            int len;
            Trit* pi;
            if ((err = tritjs_pi(&len, &pi)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(pi, len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                free(pi);
            }
        } else {
            printf("Error: Unknown command or missing argument\n");
        }

        tritbig_free(a);
        if (b) tritbig_free(b);
    }
}

@*1 Main Function.
Launches the interactive calculator.

@c
int main() {
    run_calculator();
    return 0;
}
