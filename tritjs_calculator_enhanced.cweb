@* TritJS: Advanced Ternary Scientific Calculator with Complex Number Support.
This document defines \.{TritJS}, a library for ternary (base-3) arithmetic and scientific operations,
adapted from a JavaScript module into C. It supports basic arithmetic (addition, subtraction, multiplication,
division), scientific functions (exponentiation, square roots, base-3 logarithms, sine, cosine, tangent,
factorials), and constants like Ï€, all operating on trit arrays (digits in $\{0, 1, 2\}$). Key enhancements
include:

- Fractional support via `TritFloat` for precise results.
- Arbitrary-precision arithmetic via `TritBigInt` for large numbers.
- Complex number support via `TritComplex` for operations yielding real and imaginary parts (e.g., sqrt(-1), log3).
- Optimized native fractional division with sign handling.
- An interactive CLI with comprehensive operation support.
- Refined error handling with detailed diagnostics.

The library emulates ternary computation on binary hardware, prioritizing trit-based operations and extending to complex arithmetic for AI-inspired applications.

@c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

@*1 Error Handling.
Expanded error codes for complex operations.

@d TritError int
@d TRIT_OK 0
@d TRIT_ERR_MEM 1
@d TRIT_ERR_INPUT 2
@d TRIT_ERR_DIV_ZERO 3
@d TRIT_ERR_OVERFLOW 4
@d TRIT_ERR_UNDEFINED 5
@d TRIT_ERR_NEGATIVE 6
@d TRIT_ERR_PRECISION 7

const char* trit_error_str(TritError err) {
    switch (err) {
        case TRIT_OK: return "No error";
        case TRIT_ERR_MEM: return "Memory allocation failed";
        case TRIT_ERR_INPUT: return "Invalid input (use trits 0-2)";
        case TRIT_ERR_DIV_ZERO: return "Division by zero";
        case TRIT_ERR_OVERFLOW: return "Overflow or value too large";
        case TRIT_ERR_UNDEFINED: return "Operation undefined";
        case TRIT_ERR_NEGATIVE: return "Negative input handled as complex";
        case TRIT_ERR_PRECISION: return "Precision limit exceeded";
        default: return "Unknown error";
    }
}

@*1 Data Structures and Constants.
Includes `TritComplex` for complex numbers.

@d TRIT_MAX 3
typedef int Trit;
typedef struct {
    int sign;            /* 0 = positive, 1 = negative */
    Trit* digits;        /* Magnitude as trits (0-2) */
    int len;             /* Number of trits */
} TritBigInt;
typedef struct {
    int sign;            /* 0 = positive, 1 = negative */
    Trit* integer;       /* Integer part magnitude */
    Trit* fraction;      /* Fractional part magnitude */
    int i_len;           /* Length of integer part */
    int f_len;           /* Length of fractional part */
} TritFloat;
typedef struct {
    TritFloat real;      /* Real part */
    TritFloat imag;      /* Imaginary part */
} TritComplex;
typedef struct {
    TritFloat quotient;  /* Division result */
    TritFloat remainder; /* Division remainder */
} TritDivResult;

@*1 Helper Functions.
Updated for optimization and complex support.

@<Conversion Functions@>
@<Arithmetic Helpers@>
@<Big Integer Helpers@>
@<Float Helpers@>
@<Complex Helpers@>

@<Conversion Functions@>=
TritError trits_to_binary(Trit* trits, int len, unsigned long* result) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT;
    *result = 0;
    for (int i = 0; i < len; i++) {
        if (trits[i] > 2) return TRIT_ERR_INPUT;
        if (*result > ULONG_MAX >> 2) return TRIT_ERR_OVERFLOW;
        *result = (*result << 2) | trits[i];
    }
    return TRIT_OK;
}

TritError binary_to_trits(unsigned long bin, int len, Trit** trits) {
    if (len <= 0) return TRIT_ERR_INPUT;
    *trits = (Trit*)malloc(len * sizeof(Trit));
    if (!*trits) return TRIT_ERR_MEM;
    for (int i = len - 1; i >= 0; i--) {
        (*trits)[i] = bin & 0x3;
        bin >>= 2;
    }
    return TRIT_OK;
}

@<Arithmetic Helpers@>=
typedef struct { Trit value; int carry; } TritSum;
TritSum trit_add(Trit a, Trit b) {
    int sum = a + b;
    return (TritSum){ sum % TRIT_MAX, sum / TRIT_MAX };
}

typedef struct { Trit value; int borrow; } TritDiff;
TritDiff trit_subtract(Trit a, Trit b) {
    int diff = a - b;
    if (diff >= 0) return (TritDiff){ diff, 0 };
    return (TritDiff){ (diff + TRIT_MAX) % TRIT_MAX, 1 };
}

typedef struct { Trit value; int carry; } TritProd;
TritProd trit_multiply(Trit a, Trit b) {
    int prod = a * b;
    return (TritProd){ prod % TRIT_MAX, prod / TRIT_MAX };
}

@<Big Integer Helpers@>=
TritError tritbig_from_trits(Trit* trits, int len, int sign, TritBigInt** bi) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT;
    *bi = (TritBigInt*)malloc(sizeof(TritBigInt));
    if (!*bi) return TRIT_ERR_MEM;
    (*bi)->digits = (Trit*)malloc(len * sizeof(Trit));
    if (!(*bi)->digits) {
        free(*bi);
        return TRIT_ERR_MEM;
    }
    memcpy((*bi)->digits, trits, len * sizeof(Trit));
    (*bi)->len = len;
    (*bi)->sign = sign;
    return TRIT_OK;
}

void tritbig_free(TritBigInt* bi) {
    if (bi) {
        free(bi->digits);
        free(bi);
    }
}

@<Float Helpers@>=
TritError tritfloat_from_bigint(TritBigInt* bi, TritFloat* tf) {
    if (!bi || bi->len <= 0) return TRIT_ERR_INPUT;
    tf->integer = (Trit*)malloc(bi->len * sizeof(Trit));
    if (!tf->integer) return TRIT_ERR_MEM;
    memcpy(tf->integer, bi->digits, bi->len * sizeof(Trit));
    tf->i_len = bi->len;
    tf->fraction = NULL;
    tf->f_len = 0;
    tf->sign = bi->sign;
    return TRIT_OK;
}

void tritfloat_free(TritFloat tf) {
    free(tf.integer);
    if (tf.f_len > 0) free(tf.fraction);
}

@<Complex Helpers@>=
TritError tritcomplex_from_float(TritFloat real, TritFloat imag, TritComplex* tc) {
    tc->real = real;
    tc->imag = imag;
    return TRIT_OK;
}

TritError tritcomplex_from_bigint(TritBigInt* real_bi, TritBigInt* imag_bi, TritComplex* tc) {
    TritError err;
    if ((err = tritfloat_from_bigint(real_bi, &tc->real)) != TRIT_OK) return err;
    if ((err = tritfloat_from_bigint(imag_bi, &tc->imag)) != TRIT_OK) {
        tritfloat_free(tc->real);
        return err;
    }
    return TRIT_OK;
}

void tritcomplex_free(TritComplex tc) {
    tritfloat_free(tc.real);
    tritfloat_free(tc.imag);
}

@*1 Core Arithmetic Operations.
Optimized division with sign handling.

@c
TritError tritjs_add_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    int max_len = (a->len > b->len) ? a->len : b->len;
    Trit* temp = (Trit*)malloc((max_len + 1) * sizeof(Trit));
    if (!temp) return TRIT_ERR_MEM;
    int carry = 0, pos = 0;

    if (a->sign == b->sign) {
        for (int i = max_len - 1; i >= 0; i--) {
            Trit a_trit = (i < a->len) ? a->digits[i] : 0;
            Trit b_trit = (i < b->len) ? b->digits[i] : 0;
            TritSum sum = trit_add(a_trit + carry, b_trit);
            temp[max_len - pos] = sum.value;
            carry = sum.carry;
            pos++;
        }
        int result_len = carry ? max_len + 1 : max_len;
        if (!carry) memmove(temp, temp + 1, max_len * sizeof(Trit));
        else temp[0] = carry;
        TritError err = tritbig_from_trits(temp, result_len, a->sign, result);
        free(temp);
        return err;
    } else {
        TritBigInt* larger = (a->len > b->len || (a->len == b->len && memcmp(a->digits, b->digits, a->len * sizeof(Trit)) >= 0)) ? a : b;
        TritBigInt* smaller = (larger == a) ? b : a;
        int sign = larger->sign;
        for (int i = max_len - 1; i >= 0; i--) {
            Trit l_trit = (i < larger->len) ? larger->digits[i] : 0;
            Trit s_trit = (i < smaller->len) ? smaller->digits[i] : 0;
            TritDiff diff = trit_subtract(l_trit - carry, s_trit);
            temp[max_len - pos] = diff.value;
            carry = diff.borrow;
            pos++;
        }
        int start = 0;
        while (start < max_len - 1 && temp[start] == 0) start++;
        int result_len = max_len - start;
        TritError err = tritbig_from_trits(temp + start, result_len, sign, result);
        free(temp);
        return err;
    }
}

TritError tritjs_subtract_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    TritBigInt* b_neg = (TritBigInt*)malloc(sizeof(TritBigInt));
    if (!b_neg) return TRIT_ERR_MEM;
    b_neg->digits = (Trit*)malloc(b->len * sizeof(Trit));
    if (!b_neg->digits) {
        free(b_neg);
        return TRIT_ERR_MEM;
    }
    memcpy(b_neg->digits, b->digits, b->len * sizeof(Trit));
    b_neg->len = b->len;
    b_neg->sign = !b->sign;
    TritError err = tritjs_add_big(a, b_neg, result);
    tritbig_free(b_neg);
    return err;
}

TritError tritjs_multiply_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    int max_len = a->len + b->len;
    Trit* temp = (Trit*)calloc(max_len, sizeof(Trit));
    if (!temp) return TRIT_ERR_MEM;
    for (int i = a->len - 1; i >= 0; i--) {
        int carry = 0;
        for (int j = b->len - 1; j >= 0; j--) {
            int pos = i + j + 1;
            TritProd prod = trit_multiply(a->digits[i], b->digits[j]);
            TritSum sum = trit_add(temp[pos] + carry, prod.value);
            temp[pos] = sum.value;
            carry = sum.carry + prod.carry;
        }
        if (carry) {
            int carry_pos = i;
            TritSum sum = trit_add(temp[carry_pos] + carry, 0);
            temp[carry_pos] = sum.value;
            if (sum.carry) {
                memmove(temp, temp + 1, max_len * sizeof(Trit));
                temp[0] = sum.carry;
                max_len++;
            }
        }
    }
    int start = 0;
    while (start < max_len - 1 && temp[start] == 0) start++;
    int sign = (a->sign == b->sign) ? 0 : 1;
    TritError err = tritbig_from_trits(temp + start, max_len - start, sign, result);
    free(temp);
    return err;
}

TritError tritjs_divide_big(TritBigInt* a, TritBigInt* b, TritDivResult* result, int precision) {
    if (!a || !b) return TRIT_ERR_INPUT;
    if (precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;

    /* Check divisor zero */
    int b_is_zero = 1;
    for (int i = 0; i < b->len; i++) {
        if (b->digits[i] != 0) {
            b_is_zero = 0;
            break;
        }
    }
    if (b_is_zero) return TRIT_ERR_DIV_ZERO;

    /* Convert inputs to TritFloat */
    TritFloat dividend, divisor;
    TritError err;
    if ((err = tritfloat_from_bigint(a, Ã·nd)) != TRIT_OK) return err;
    if ((err = tritfloat_from_bigint(b, &divisor)) != TRIT_OK) {
        tritfloat_free(dividend);
        return err;
    }

    /* Allocate quotient and remainder */
    result->quotient.integer = (Trit*)calloc(a->len, sizeof(Trit));
    if (!result->quotient.integer) {
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return TRIT_ERR_MEM;
    }
    result->quotient.fraction = (Trit*)calloc(precision, sizeof(Trit));
    if (!result->quotient.fraction) {
        free(result->quotient.integer);
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return TRIT_ERR_MEM;
    }
    result->remainder.integer = (Trit*)malloc(b->len * sizeof(Trit));
    if (!result->remainder.integer) {
        free(result->quotient.integer);
        free(result->quotient.fraction);
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return TRIT_ERR_MEM;
    }
    result->remainder.fraction = NULL;
    result->quotient.i_len = a->len;
    result->quotient.f_len = precision;
    result->remainder.i_len = b->len;
    result->remainder.f_len = 0;
    result->quotient.sign = (a->sign == b->sign) ? 0 : 1;
    result->remainder.sign = a->sign;

    /* Precompute divisor multiples */
    TritBigInt* b_one = NULL;
    TritBigInt* b_two = NULL;
    if ((err = tritbig_from_trits(b->digits, b->len, 0, &b_one)) != TRIT_OK) {
        tritfloat_free(result->quotient);
        tritfloat_free(result->remainder);
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return err;
    }
    TritBigInt* two;
    if ((err = tritbig_from_trits((Trit[]){2}, 1, 0, &two)) != TRIT_OK) {
        tritbig_free(b_one);
        tritfloat_free(result->quotient);
        tritfloat_free(result->remainder);
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return err;
    }
    if ((err = tritjs_multiply_big(b_one, two, &b_two)) != TRIT_OK) {
        tritbig_free(b_one);
        tritbig_free(two);
        tritfloat_free(result->quotient);
        tritfloat_free(result->remainder);
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return err;
    }
    tritbig_free(two);

    /* Initialize remainder */
    memcpy(result->remainder.integer, a->digits, a->len * sizeof(Trit));
    TritBigInt* temp_rem;
    if ((err = tritbig_from_trits(result->remainder.integer, result->remainder.i_len, result->remainder.sign, &temp_rem)) != TRIT_OK) {
        tritbig_free(b_one);
        tritbig_free(b_two);
        tritfloat_free(result->quotient);
        tritfloat_free(result->remainder);
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return err;
    }

    /* Integer division with binary search */
    for (int i = 0; i < a->len; i++) {
        int low = 0, high = 2, digit = 0;
        while (low <= high) {
            int mid = (low + high) / 2;
            TritBigInt* multiple = (mid == 1) ? b_one : (mid == 2) ? b_two : NULL;
            if (mid == 0) {
                digit = 0;
                break;
            }
            TritBigInt* temp_sub;
            if ((err = tritjs_subtract_big(temp_rem, multiple, &temp_sub)) != TRIT_OK) {
                if (err == TRIT_ERR_NEGATIVE) {
                    high = mid - 1;
                } else {
                    tritbig_free(temp_rem);
                    tritbig_free(b_one);
                    tritbig_free(b_two);
                    tritfloat_free(result->quotient);
                    tritfloat_free(result->remainder);
                    tritfloat_free(dividend);
                    tritfloat_free(divisor);
                    return err;
                }
            } else {
                digit = mid;
                low = mid + 1;
                tritbig_free(temp_rem);
                temp_rem = temp_sub;
            }
        }
        result->quotient.integer[i] = digit;
        memcpy(result->remainder.integer, temp_rem->digits, temp_rem->len * sizeof(Trit));
        result->remainder.i_len = temp_rem->len;
    }

    /* Fractional division */
    for (int i = 0; i < precision; i++) {
        TritBigInt* three;
        if ((err = tritbig_from_trits((Trit[]){1}, 1, 0, &three)) != TRIT_OK) {
            tritbig_free(temp_rem);
            tritbig_free(b_one);
            tritbig_free(b_two);
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return err;
        }
        TritBigInt* temp_mul;
        if ((err = tritjs_multiply_big(temp_rem, three, &temp_mul)) != TRIT_OK) {
            tritbig_free(temp_rem);
            tritbig_free(three);
            tritbig_free(b_one);
            tritbig_free(b_two);
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return err;
        }
        tritbig_free(temp_rem);
        tritbig_free(three);
        temp_rem = temp_mul;

        int low = 0, high = 2, digit = 0;
        while (low <= high) {
            int mid = (low + high) / 2;
            TritBigInt* multiple = (mid == 1) ? b_one : (mid == 2) ? b_two : NULL;
            if (mid == 0) {
                digit = 0;
                break;
            }
            TritBigInt* temp_sub;
            if ((err = tritjs_subtract_big(temp_rem, multiple, &temp_sub)) != TRIT_OK) {
                if (err == TRIT_ERR_NEGATIVE) {
                    high = mid - 1;
                } else {
                    tritbig_free(temp_rem);
                    tritbig_free(b_one);
                    tritbig_free(b_two);
                    tritfloat_free(result->quotient);
                    tritfloat_free(result->remainder);
                    tritfloat_free(dividend);
                    tritfloat_free(divisor);
                    return err;
                }
            } else {
                digit = mid;
                low = mid + 1;
                tritbig_free(temp_rem);
                temp_rem = temp_sub;
            }
        }
        result->quotient.fraction[i] = digit;
        memcpy(result->remainder.integer, temp_rem->digits, temp_rem->len * sizeof(Trit));
        result->remainder.i_len = temp_rem->len;
    }

    int int_start = 0;
    while (int_start < result->quotient.i_len - 1 && result->quotient.integer[int_start] == 0) int_start++;
    if (int_start > 0) {
        Trit* new_int = (Trit*)malloc((result->quotient.i_len - int_start) * sizeof(Trit));
        if (!new_int) {
            tritbig_free(temp_rem);
            tritbig_free(b_one);
            tritbig_free(b_two);
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return TRIT_ERR_MEM;
        }
        memcpy(new_int, result->quotient.integer + int_start, (result->quotient.i_len - int_start) * sizeof(Trit));
        free(result->quotient.integer);
        result->quotient.integer = new_int;
        result->quotient.i_len -= int_start;
    }

    tritbig_free(temp_rem);
    tritbig_free(b_one);
    tritbig_free(b_two);
    tritfloat_free(dividend);
    tritfloat_free(divisor);
    return TRIT_OK;
}

@*1 Scientific Operations.
Added complex logarithm support.

@c
TritError tritjs_power_big(TritBigInt* base, TritBigInt* exp, TritBigInt** result) {
    if (!base || !exp) return TRIT_ERR_INPUT;
    if (exp->sign) return TRIT_ERR_NEGATIVE;
    TritError err;
    if ((err = tritbig_from_trits((Trit[]){1}, 1, 0, result)) != TRIT_OK) return err;
    unsigned long exp_bin;
    if ((err = trits_to_binary(exp->digits, exp->len, &exp_bin)) != TRIT_OK) {
        tritbig_free(*result);
        return err;
    }
    if (exp_bin > 1000) {
        tritbig_free(*result);
        return TRIT_ERR_OVERFLOW;
    }
    int sign = (base->sign && (exp_bin % 2 == 1)) ? 1 : 0;
    for (unsigned long i = 0; i < exp_bin; i++) {
        TritBigInt* temp;
        if ((err = tritjs_multiply_big(*result, base, &temp)) != TRIT_OK) {
            tritbig_free(*result);
            return err;
        }
        tritbig_free(*result);
        *result = temp;
    }
    (*result)->sign = sign;
    return TRIT_OK;
}

TritError tritjs_sqrt_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    double a_val = (double)a_bin * (a->sign ? -1 : 1);
    if (a_val >= 0) {
        double sqrt_val = sqrt(a_val);
        unsigned long int_part = (unsigned long)sqrt_val;
        double frac_part = sqrt_val - int_part;
        if ((err = binary_to_trits(int_part, (a->len + 1) / 2, &result->real.integer)) != TRIT_OK) return err;
        if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->real.fraction)) != TRIT_OK) {
            free(result->real.integer);
            return err;
        }
        result->real.i_len = (a->len + 1) / 2;
        result->real.f_len = precision;
        result->real.sign = 0;
        result->imag.integer = (Trit*)malloc(1 * sizeof(Trit));
        if (!result->imag.integer) {
            tritfloat_free(result->real);
            return TRIT_ERR_MEM;
        }
        result->imag.integer[0] = 0;
        result->imag.i_len = 1;
        result->imag.fraction = (Trit*)malloc(precision * sizeof(Trit));
        if (!result->imag.fraction) {
            free(result->imag.integer);
            tritfloat_free(result->real);
            return TRIT_ERR_MEM;
        }
        memset(result->imag.fraction, 0, precision * sizeof(Trit));
        result->imag.f_len = precision;
        result->imag.sign = 0;
    } else {
        double sqrt_val = sqrt(-a_val);
        unsigned long int_part = (unsigned long)sqrt_val;
        double frac_part = sqrt_val - int_part;
        result->real.integer = (Trit*)malloc(1 * sizeof(Trit));
        if (!result->real.integer) return TRIT_ERR_MEM;
        result->real.integer[0] = 0;
        result->real.i_len = 1;
        result->real.fraction = (Trit*)malloc(precision * sizeof(Trit));
        if (!result->real.fraction) {
            free(result->real.integer);
            return TRIT_ERR_MEM;
        }
        memset(result->real.fraction, 0, precision * sizeof(Trit));
        result->real.f_len = precision;
        result->real.sign = 0;
        if ((err = binary_to_trits(int_part, (a->len + 1) / 2, &result->imag.integer)) != TRIT_OK) {
            tritfloat_free(result->real);
            return err;
        }
        if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->imag.fraction)) != TRIT_OK) {
            free(result->imag.integer);
            tritfloat_free(result->real);
            return err;
        }
        result->imag.i_len = (a->len + 1) / 2;
        result->imag.f_len = precision;
        result->imag.sign = 0;
    }
    return TRIT_OK;
}

TritError tritjs_log3_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    double a_real = (double)a_bin * (a->sign ? -1 : 1);
    double a_imag = 0; /* Assume imaginary part is 0 for simplicity */
    double magnitude = sqrt(a_real * a_real + a_imag * a_imag);
    double arg = atan2(a_imag, a_real);
    double ln3 = log(3.0);

    /* Real part: log3(|z|) */
    double real_val = log(magnitude) / ln3;
    int real_sign = (real_val < 0) ? 1 : 0;
    double real_abs = fabs(real_val);
    unsigned long real_int = (unsigned long)real_abs;
    double real_frac = real_abs - real_int;
    if ((err = binary_to_trits(real_int, a->len, &result->real.integer)) != TRIT_OK) return err;
    if ((err = binary_to_trits((unsigned long)(real_frac * pow(3, precision)), precision, &result->real.fraction)) != TRIT_OK) {
        free(result->real.integer);
        return err;
    }
    result->real.i_len = a->len;
    result->real.f_len = precision;
    result->real.sign = real_sign;

    /* Imaginary part: arg(z) / ln(3) */
    double imag_val = arg / ln3;
    int imag_sign = (imag_val < 0) ? 1 : 0;
    double imag_abs = fabs(imag_val);
    unsigned long imag_int = (unsigned long)imag_abs;
    double imag_frac = imag_abs - imag_int;
    if ((err = binary_to_trits(imag_int, a->len, &result->imag.integer)) != TRIT_OK) {
        tritfloat_free(result->real);
        return err;
    }
    if ((err = binary_to_trits((unsigned long)(imag_frac * pow(3, precision)), precision, &result->imag.fraction)) != TRIT_OK) {
        free(result->imag.integer);
        tritfloat_free(result->real);
        return err;
    }
    result->imag.i_len = a->len;
    result->imag.f_len = precision;
    result->imag.sign = imag_sign;

    return TRIT_OK;
}

TritError tritjs_sin_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    int pi_len;
    Trit* pi;
    if ((err = tritjs_pi(&pi_len, &pi)) != TRIT_OK) return err;
    unsigned long pi_bin;
    if ((err = trits_to_binary(pi, pi_len, &pi_bin)) != TRIT_OK) {
        free(pi);
        return err;
    }
    double a_rad = (double)a_bin * M_PI / (double)pi_bin * (a->sign ? -1 : 1);
    double sin_val = sin(a_rad);
    int sign = (sin_val < 0) ? 1 : 0;
    double abs_val = fabs(sin_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;
    if ((err = binary_to_trits(int_part, 1, &result->real.integer)) != TRIT_OK) {
        free(pi);
        return err;
    }
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->real.fraction)) != TRIT_OK) {
        free(result->real.integer);
        free(pi);
        return err;
    }
    result->real.i_len = 1;
    result->real.f_len = precision;
    result->real.sign = sign;
    result->imag.integer = (Trit*)malloc(1 * sizeof(Trit));
    if (!result->imag.integer) {
        tritfloat_free(result->real);
        free(pi);
        return TRIT_ERR_MEM;
    }
    result->imag.integer[0] = 0;
    result->imag.i_len = 1;
    result->imag.fraction = (Trit*)malloc(precision * sizeof(Trit));
    if (!result->imag.fraction) {
        free(result->imag.integer);
        tritfloat_free(result->real);
        free(pi);
        return TRIT_ERR_MEM;
    }
    memset(result->imag.fraction, 0, precision * sizeof(Trit));
    result->imag.f_len = precision;
    result->imag.sign = 0;
    free(pi);
    return TRIT_OK;
}

TritError tritjs_cos_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    int pi_len;
    Trit* pi;
    if ((err = tritjs_pi(&pi_len, &pi)) != TRIT_OK) return err;
    unsigned long pi_bin;
    if ((err = trits_to_binary(pi, pi_len, &pi_bin)) != TRIT_OK) {
        free(pi);
        return err;
    }
    double a_rad = (double)a_bin * M_PI / (double)pi_bin * (a->sign ? -1 : 1);
    double cos_val = cos(a_rad);
    int sign = (cos_val < 0) ? 1 : 0;
    double abs_val = fabs(cos_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;
    if ((err = binary_to_trits(int_part, 1, &result->real.integer)) != TRIT_OK) {
        free(pi);
        return err;
    }
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->real.fraction)) != TRIT_OK) {
        free(result->real.integer);
        free(pi);
        return err;
    }
    result->real.i_len = 1;
    result->real.f_len = precision;
    result->real.sign = sign;
    result->imag.integer = (Trit*)malloc(1 * sizeof(Trit));
    if (!result->imag.integer) {
        tritfloat_free(result->real);
        free(pi);
        return TRIT_ERR_MEM;
    }
    result->imag.integer[0] = 0;
    result->imag.i_len = 1;
    result->imag.fraction = (Trit*)malloc(precision * sizeof(Trit));
    if (!result->imag.fraction) {
        free(result->imag.integer);
        tritfloat_free(result->real);
        free(pi);
        return TRIT_ERR_MEM;
    }
    memset(result->imag.fraction, 0, precision * sizeof(Trit));
    result->imag.f_len = precision;
    result->imag.sign = 0;
    free(pi);
    return TRIT_OK;
}

TritError tritjs_tan_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    int pi_len;
    Trit* pi;
    if ((err = tritjs_pi(&pi_len, &pi)) != TRIT_OK) return err;
    unsigned long pi_bin;
    if ((err = trits_to_binary(pi, pi_len, &pi_bin)) != TRIT_OK) {
        free(pi);
        return err;
    }
    double a_rad = (double)a_bin * M_PI / (double)pi_bin * (a->sign ? -1 : 1);
    double tan_val = tan(a_rad);
    if (fabs(tan_val) > 1000.0) {
        free(pi);
        return TRIT_ERR_UNDEFINED;
    }
    int sign = (tan_val < 0) ? 1 : 0;
    double abs_val = fabs(tan_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;
    if ((err = binary_to_trits(int_part, (int)log(abs_val)/log(3) + 1, &result->real.integer)) != TRIT_OK) {
        free(pi);
        return err;
    }
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->real.fraction)) != TRIT_OK) {
        free(result->real.integer);
        free(pi);
        return err;
    }
    result->real.i_len = (int)log(abs_val)/log(3) + 1;
    result->real.f_len = precision;
    result->real.sign = sign;
    result->imag.integer = (Trit*)malloc(1 * sizeof(Trit));
    if (!result->imag.integer) {
        tritfloat_free(result->real);
        free(pi);
        return TRIT_ERR_MEM;
    }
    result->imag.integer[0] = 0;
    result->imag.i_len = 1;
    result->imag.fraction = (Trit*)malloc(precision * sizeof(Trit));
    if (!result->imag.fraction) {
        free(result->imag.integer);
        tritfloat_free(result->real);
        free(pi);
        return TRIT_ERR_MEM;
    }
    memset(result->imag.fraction, 0, precision * sizeof(Trit));
    result->imag.f_len = precision;
    result->imag.sign = 0;
    free(pi);
    return TRIT_OK;
}

TritError tritjs_factorial_big(TritBigInt* a, TritBigInt** result) {
    if (!a) return TRIT_ERR_INPUT;
    if (a->sign) return TRIT_ERR_NEGATIVE;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    if (a_bin > 20) return TRIT_ERR_OVERFLOW;
    if ((err = tritbig_from_trits((Trit[]){1}, 1, 0, result)) != TRIT_OK) return err;
    for (unsigned long i = 1; i <= a_bin; i++) {
        Trit* i_trits;
        if ((err = binary_to_trits(i, 2, &i_trits)) != TRIT_OK) {
            tritbig_free(*result);
            return err;
        }
        TritBigInt* i_bi;
        if ((err = tritbig_from_trits(i_trits, 2, 0, &i_bi)) != TRIT_OK) {
            free(i_trits);
            tritbig_free(*result);
            return err;
        }
        free(i_trits);
        TritBigInt* temp;
        if ((err = tritjs_multiply_big(*result, i_bi, &temp)) != TRIT_OK) {
            tritbig_free(i_bi);
            tritbig_free(*result);
            return err;
        }
        tritbig_free(*result);
        tritbig_free(i_bi);
        *result = temp;
    }
    return TRIT_OK;
}

TritError tritjs_pi(int* len, Trit** pi) {
    Trit pi_val[] = {1, 0, 0, 1, 0, 2, 2, 1};
    *len = 8;
    *pi = (Trit*)malloc(*len * sizeof(Trit));
    if (!*pi) return TRIT_ERR_MEM;
    memcpy(*pi, pi_val, *len * sizeof(Trit));
    return TRIT_OK;
}

@*1 Utility Functions.
Updated for complex numbers.

@c
TritError tritjs_to_string(Trit* trits, int len, char** str) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT;
    *str = (char*)malloc(len + 1);
    if (!*str) return TRIT_ERR_MEM;
    for (int i = 0; i < len; i++) (*str)[i] = '0' + trits[i];
    (*str)[len] = '\0';
    return TRIT_OK;
}

TritError tritfloat_to_string(TritFloat tf, char** str) {
    if (!tf.integer || tf.i_len <= 0) return TRIT_ERR_INPUT;
    char* mag_str;
    TritError err;
    if ((err = tritjs_to_string(tf.integer, tf.i_len, &mag_str)) != TRIT_OK) return err;
    if (tf.f_len > 0) {
        char* frac_str;
        if ((err = tritjs_to_string(tf.fraction, tf.f_len, &frac_str)) != TRIT_OK) {
            free(mag_str);
            return err;
        }
        *str = (char*)malloc(tf.i_len + tf.f_len + 2 + (tf.sign ? 1 : 0));
        if (!*str) {
            free(mag_str);
            free(frac_str);
            return TRIT_ERR_MEM;
        }
        sprintf(*str, "%s%s.%s", tf.sign ? "-" : "", mag_str, frac_str);
        free(mag_str);
        free(frac_str);
    } else {
        *str = (char*)malloc(tf.i_len + 1 + (tf.sign ? 1 : 0));
        if (!*str) {
            free(mag_str);
            return TRIT_ERR_MEM;
        }
        sprintf(*str, "%s%s", tf.sign ? "-" : "", mag_str);
        free(mag_str);
    }
    return TRIT_OK;
}

TritError tritcomplex_to_string(TritComplex tc, char** str) {
    char* real_str;
    char* imag_str;
    TritError err;
    if ((err = tritfloat_to_string(tc.real, &real_str)) != TRIT_OK) return err;
    if ((err = tritfloat_to_string(tc.imag, &imag_str)) != TRIT_OK) {
        free(real_str);
        return err;
    }
    int imag_zero = (tc.imag.i_len == 1 && tc.imag.integer[0] == 0 && tc.imag.f_len == 0);
    if (imag_zero) {
        *str = real_str;
        free(imag_str);
        return TRIT_OK;
    }
    *str = (char*)malloc(strlen(real_str) + strlen(imag_str) + 4);
    if (!*str) {
        free(real_str);
        free(imag_str);
        return TRIT_ERR_MEM;
    }
    sprintf(*str, "%s %si", real_str, imag_str);
    free(real_str);
    free(imag_str);
    return TRIT_OK;
}

@*1 CLI Functions.
Updated with optimized division and complex log.

@c
TritError parse_trit_string(const char* str, TritBigInt** bi) {
    if (!str || strlen(str) == 0) return TRIT_ERR_INPUT;
    int sign = (str[0] == '-') ? 1 : 0;
    const char* mag_str = (str[0] == '-') ? str + 1 : str;
    int len = strlen(mag_str);
    Trit* trits = (Trit*)malloc(len * sizeof(Trit));
    if (!trits) return TRIT_ERR_MEM;
    for (int i = 0; i < len; i++) {
        if (mag_str[i] < '0' || mag_str[i] > '2') {
            free(trits);
            return TRIT_ERR_INPUT;
        }
        trits[i] = mag_str[i] - '0';
    }
    TritError err = tritbig_from_trits(trits, len, sign, bi);
    free(trits);
    return err;
}

@d MAX_HELP_CATEGORIES 4
@d MAX_HELP_ENTRIES 15

typedef struct {
    const char* command;
    const char* description;
} TritHelpEntry;

typedef struct {
    const char* category;
    TritHelpEntry entries[MAX_HELP_ENTRIES];
} TritHelpCategory;

TritHelpCategory help_categories[MAX_HELP_CATEGORIES] = {
    {
        "Arithmetic Operations", {
            {"add", "Adds two ternary numbers or complex numbers."},
            {"sub", "Subtracts the second number from the first."},
            {"mul", "Multiplies two numbers in base-3."},
            {"div", "Divides two numbers, showing quotient and remainder."},
            {"pow", "Raises a number to a ternary exponent."},
            {"fact", "Computes the factorial of a number."},
            {NULL, NULL}
        }
    },
    {
        "Scientific Functions", {
            {"sqrt", "Computes the square root (supports complex numbers)."},
            {"log3", "Computes the base-3 logarithm (supports complex)."},
            {"pi", "Displays the value of Ï€ in base-3."},
            {NULL, NULL}
        }
    },
    {
        "Trigonometric Functions", {
            {"sin", "Computes the sine function."},
            {"cos", "Computes the cosine function."},
            {"tan", "Computes the tangent function."},
            {NULL, NULL}
        }
    },
    {
        "General Commands", {
            {"help", "Displays this help message."},
            {"quit", "Exits the calculator."},
            {NULL, NULL}
        }
    }
};

#include <string.h>

void print_help(const char* search) {
    int found = 0;
    printf("\nTritJS Help Documentation:\n");
    printf("===========================\n");

    for (int i = 0; i < MAX_HELP_CATEGORIES; i++) {
        int category_has_matches = 0;

        for (int j = 0; help_categories[i].entries[j].command != NULL; j++) {
            if (search == NULL || strstr(help_categories[i].entries[j].command, search) != NULL) {
                if (!category_has_matches) {
                    printf("\n%s:\n", help_categories[i].category);
                    printf("-------------------------\n");
                    category_has_matches = 1;
                }
                printf("  %-6s - %s\n", help_categories[i].entries[j].command, help_categories[i].entries[j].description);
                found = 1;
            }
        }
    }

    if (!found) {
        printf("\nNo matching commands found for '%s'.\n", search);
        printf("Type 'help' to see all available commands.\n");
    }

    printf("\n===========================\n\n");
}


void run_calculator() {
    char input[256];
    printf("TritJS Ternary Calculator (enter 'quit' to exit)\n");
    printf("Commands: add/sub/mul/div/pow/sqrt/log3/sin/cos/tan/fact/pi <arg1> [arg2]\n");
    while (1) {
        printf("> ");
        if (!fgets(input, 256, stdin)) break;
        input[strcspn(input, "\n")] = 0;
        if (strcmp(input, "quit") == 0) break;
        if (strcmp(input, "help") == 0) {
            print_help();
            continue;
        }
        char op[10], arg1[20], arg2[20] = "";
        int parsed = sscanf(input, "%9s %19s %19s", op, arg1, arg2);
        if (parsed < 2) {
            printf("Error: Invalid command format (e.g., 'add 12 2')\n");
            continue;
        }

        TritBigInt* a = NULL;
        TritBigInt* b = NULL;
        TritError err;

        if ((err = parse_trit_string(arg1, &a)) != TRIT_OK) {
            printf("Error with arg1: %s\n", trit_error_str(err));
            continue;
        }
        if (strlen(arg2) > 0) {
            if ((err = parse_trit_string(arg2, &b)) != TRIT_OK) {
                printf("Error with arg2: %s\n", trit_error_str(err));
                tritbig_free(a);
                continue;
            }
        }

        if (strcmp(op, "add") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_add_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s%s\n", result->sign ? "-" : "", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "sub") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_subtract_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s%s\n", result->sign ? "-" : "", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "mul") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_multiply_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s%s\n", result->sign ? "-" : "", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "div") == 0 && b) {
            TritDivResult result;
            if ((err = tritjs_divide_big(a, b, &result, 3)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* q_str;
                char* r_str;
                if ((err = tritfloat_to_string(result.quotient, &q_str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else if ((err = tritfloat_to_string(result.remainder, &r_str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                    free(q_str);
                } else {
                    printf("%s r %s\n", q_str, r_str);
                    free(q_str);
                    free(r_str);
                }
                tritfloat_free(result.quotient);
                tritfloat_free(result.remainder);
            }
        } else if (strcmp(op, "pow") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_power_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s%s\n", result->sign ? "-" : "", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "sqrt") == 0) {
            TritComplex result;
            if ((err = tritjs_sqrt_complex(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritcomplex_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritcomplex_free(result);
            }
        } else if (strcmp(op, "log3") == 0) {
            TritComplex result;
            if ((err = tritjs_log3_complex(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritcomplex_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritcomplex_free(result);
            }
        } else if (strcmp(op, "sin") == 0) {
            TritComplex result;
            if ((err = tritjs_sin_complex(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritcomplex_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritcomplex_free(result);
            }
        } else if (strcmp(op, "cos") == 0) {
            TritComplex result;
            if ((err = tritjs_cos_complex(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritcomplex_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritcomplex_free(result);
            }
        } else if (strcmp(op, "tan") == 0) {
            TritComplex result;
            if ((err = tritjs_tan_complex(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritcomplex_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritcomplex_free(result);
            }
        } else if (strcmp(op, "fact") == 0) {
            TritBigInt* result;
            if ((err = tritjs_factorial_big(a, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s%s\n", result->sign ? "-" : "", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "pi") == 0) {
            int len;
            Trit* pi;
            if ((err = tritjs_pi(&len, &pi)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(pi, len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                free(pi);
            }
        } else {
            printf("Error: Unknown command or missing argument\n");
        }

        tritbig_free(a);
        if (b) tritbig_free(b);
    }
}

@*1 Main Function.
Launches the calculator.

@c
int main() {
    run_calculator();
    return 0;
}
