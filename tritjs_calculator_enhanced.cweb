@* TritJS: Enhanced Ternary Scientific Calculator with Advanced Features.
This document defines \.{TritJS}, a library for ternary (base-3) arithmetic and scientific operations,
adapted from a JavaScript module into C. It supports basic arithmetic (addition, subtraction, multiplication,
division), scientific functions (exponentiation, square roots, base-3 logarithms, sine, cosine, tangent,
factorials), and constants like π, all operating on trit arrays (digits in $\{0, 1, 2\}$). Key enhancements
include:

- Fractional support via `TritFloat` for precise results (e.g., sin(12₃) ≈ 0.221₃).
- Arbitrary-precision arithmetic via `TritBigInt` to handle large numbers.
- Accurate trigonometric scaling using a ternary π constant.
- Native fractional division in `tritjs_divide_big` using `TritFloat`.
- An interactive CLI with add, sub, mul, div, pow, sqrt, log3, sin, cos, tan, fact, and pi.
- Refined error handling with detailed error codes and consistent cleanup.

The library emulates ternary computation on binary hardware, prioritizing trit-based operations for precision.

@c
#include <stdio.h>  /* For printf, scanf */
#include <stdlib.h> /* For malloc, free */
#include <string.h> /* For strlen, strcmp */
#include <math.h>   /* For sqrt, sin, cos, tan, log */

@*1 Error Handling.
We define an expanded `TritError` enum for detailed error reporting, with a helper function for user feedback.

@d TritError int
@d TRIT_OK 0             /* No error occurred */
@d TRIT_ERR_MEM 1        /* Memory allocation failed */
@d TRIT_ERR_INPUT 2      /* Invalid input (e.g., non-trit digit) */
@d TRIT_ERR_DIV_ZERO 3   /* Division by zero attempted */
@d TRIT_ERR_OVERFLOW 4   /* Result too large or computation infeasible */
@d TRIT_ERR_UNDEFINED 5  /* Operation undefined (e.g., log of zero) */
@d TRIT_ERR_NEGATIVE 6   /* Negative input where not allowed */
@d TRIT_ERR_PRECISION 7  /* Precision limit exceeded */

/* Converts error codes to detailed, user-friendly messages */
const char* trit_error_str(TritError err) {
    switch (err) {
        case TRIT_OK: return "No error";
        case TRIT_ERR_MEM: return "Memory allocation failed";
        case TRIT_ERR_INPUT: return "Invalid input (use trits 0-2)";
        case TRIT_ERR_DIV_ZERO: return "Division by zero";
        case TRIT_ERR_OVERFLOW: return "Overflow or value too large";
        case TRIT_ERR_UNDEFINED: return "Operation undefined (e.g., log(0))";
        case TRIT_ERR_NEGATIVE: return "Negative input not supported";
        case TRIT_ERR_PRECISION: return "Precision limit exceeded";
        default: return "Unknown error";
    }
}

@*1 Data Structures and Constants.
Core data types for ternary computation:
- `Trit`: Single digit (0, 1, 2).
- `TritBigInt`: Arbitrary-precision integer.
- `TritFloat`: Number with integer and fractional parts.
- `TritDivResult`: Division result with quotient and remainder (now using `TritFloat`).

@d TRIT_MAX 3            /* Base-3 modulus */
typedef int Trit;        /* Single trit value */
typedef struct {
    Trit* digits;        /* Array of trits representing the number */
    int len;             /* Number of trits in the array */
} TritBigInt;
typedef struct {
    Trit* integer;       /* Integer part of the number */
    Trit* fraction;      /* Fractional part (NULL if none) */
    int i_len;           /* Length of integer part */
    int f_len;           /* Length of fractional part */
} TritFloat;
typedef struct {
    TritFloat quotient;  /* Division result as a float */
    TritFloat remainder; /* Division remainder as a float */
} TritDivResult;

@*1 Helper Functions.
Utilities for conversions, arithmetic, and structure management, with enhanced error handling.

@<Conversion Functions@>
@<Arithmetic Helpers@>
@<Big Integer Helpers@>
@<Float Helpers@>

/* Conversions between ternary and binary (used sparingly) */
@ Conversions are a fallback for initial implementations; division now uses native trit operations.
@c
@<Conversion Functions@>=
/* Converts a trit array to an unsigned long binary value */
TritError trits_to_binary(Trit* trits, int len, unsigned long* result) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT; /* Check for null or invalid length */
    *result = 0;
    for (int i = 0; i < len; i++) {
        if (trits[i] > 2) return TRIT_ERR_INPUT; /* Ensure valid trit (0-2) */
        if (*result > ULONG_MAX >> 2) return TRIT_ERR_OVERFLOW; /* Prevent overflow */
        *result = (*result << 2) | trits[i]; /* Shift left 2 bits and add trit */
    }
    return TRIT_OK;
}

/* Converts an unsigned long binary value to a trit array */
TritError binary_to_trits(unsigned long bin, int len, Trit** trits) {
    if (len <= 0) return TRIT_ERR_INPUT; /* Ensure valid length */
    *trits = (Trit*)malloc(len * sizeof(Trit));
    if (!*trits) return TRIT_ERR_MEM; /* Check allocation */
    for (int i = len - 1; i >= 0; i--) {
        (*trits)[i] = bin & 0x3; /* Extract lowest 2 bits (0, 1, or 2) */
        bin >>= 2; /* Shift right to process next trit */
    }
    return TRIT_OK;
}

/* Single-trit arithmetic operations */
@ Building blocks for multi-trit arithmetic, handling carries and borrows.
@c
@<Arithmetic Helpers@>=
typedef struct { Trit value; int carry; } TritSum; /* Result of adding two trits */
TritSum trit_add(Trit a, Trit b) { /* Adds two trits, returns value and carry */
    int sum = a + b;
    return (TritSum){ sum % TRIT_MAX, sum / TRIT_MAX };
}

typedef struct { Trit value; int borrow; } TritDiff; /* Result of subtracting two trits */
TritDiff trit_subtract(Trit a, Trit b) { /* Subtracts b from a, handles borrow */
    int diff = a - b;
    if (diff >= 0) return (TritDiff){ diff, 0 };
    return (TritDiff){ (diff + TRIT_MAX) % TRIT_MAX, 1 };
}

typedef struct { Trit value; int carry; } TritProd; /* Result of multiplying two trits */
TritProd trit_multiply(Trit a, Trit b) { /* Multiplies two trits, returns value and carry */
    int prod = a * b;
    return (TritProd){ prod % TRIT_MAX, prod / TRIT_MAX };
}

/* Helpers for TritBigInt */
@ Manage creation and destruction of big integers.
@c
@<Big Integer Helpers@>=
/* Creates a TritBigInt from an array of trits */
TritError tritbig_from_trits(Trit* trits, int len, TritBigInt** bi) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT; /* Validate input */
    *bi = (TritBigInt*)malloc(sizeof(TritBigInt));
    if (!*bi) return TRIT_ERR_MEM; /* Check structure allocation */
    (*bi)->digits = (Trit*)malloc(len * sizeof(Trit));
    if (!(*bi)->digits) {
        free(*bi); /* Free structure if digits allocation fails */
        return TRIT_ERR_MEM;
    }
    memcpy((*bi)->digits, trits, len * sizeof(Trit)); /* Copy trits */
    (*bi)->len = len;
    return TRIT_OK;
}

/* Frees a TritBigInt, safely handling NULL */
void tritbig_free(TritBigInt* bi) {
    if (bi) {
        free(bi->digits);
        free(bi);
    }
}

/* Helpers for TritFloat */
@ Manage creation, conversion, and destruction of floats.
@c
@<Float Helpers@>=
/* Converts a TritBigInt to a TritFloat with no fractional part */
TritError tritfloat_from_bigint(TritBigInt* bi, TritFloat* tf) {
    if (!bi || bi->len <= 0) return TRIT_ERR_INPUT; /* Validate input */
    tf->integer = (Trit*)malloc(bi->len * sizeof(Trit));
    if (!tf->integer) return TRIT_ERR_MEM; /* Check allocation */
    memcpy(tf->integer, bi->digits, bi->len * sizeof(Trit)); /* Copy integer part */
    tf->i_len = bi->len;
    tf->fraction = NULL; /* No fractional part initially */
    tf->f_len = 0;
    return TRIT_OK;
}

/* Frees a TritFloat, handling both parts */
void tritfloat_free(TritFloat tf) {
    free(tf.integer);
    if (tf.f_len > 0) free(tf.fraction); /* Free fraction only if present */
}

@*1 Core Arithmetic Operations.
These implement basic arithmetic on `TritBigInt` with error handling; division now supports fractions.

@c
/* Adds two TritBigInt numbers */
TritError tritjs_add_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT; /* Check for null inputs */
    int max_len = (a->len > b->len) ? a->len : b->len;
    Trit* temp = (Trit*)malloc((max_len + 1) * sizeof(Trit)); /* Extra space for carry */
    if (!temp) return TRIT_ERR_MEM;
    int carry = 0, pos = 0;

    for (int i = max_len - 1; i >= 0; i--) { /* Work from least to most significant trit */
        Trit a_trit = (i < a->len) ? a->digits[i] : 0; /* Pad with 0 if shorter */
        Trit b_trit = (i < b->len) ? b->digits[i] : 0;
        TritSum sum = trit_add(a_trit + carry, b_trit); /* Add with carry */
        temp[max_len - pos] = sum.value;
        carry = sum.carry;
        pos++;
    }
    int result_len = carry ? max_len + 1 : max_len; /* Include carry if present */
    if (!carry) memmove(temp, temp + 1, max_len * sizeof(Trit)); /* Shift if no carry */
    else temp[0] = carry;
    TritError err = tritbig_from_trits(temp, result_len, result);
    free(temp);
    return err;
}

/* Subtracts b from a (TritBigInt) */
TritError tritjs_subtract_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    int max_len = (a->len > b->len) ? a->len : b->len;
    Trit* temp = (Trit*)malloc(max_len * sizeof(Trit));
    if (!temp) return TRIT_ERR_MEM;
    int borrow = 0;

    for (int i = max_len - 1; i >= 0; i--) {
        Trit a_trit = (i < a->len) ? a->digits[i] : 0;
        Trit b_trit = (i < b->len) ? b->digits[i] : 0;
        TritDiff diff = trit_subtract(a_trit - borrow, b_trit); /* Subtract with borrow */
        temp[i] = diff.value;
        borrow = diff.borrow;
    }
    int start = 0;
    while (start < max_len - 1 && temp[start] == 0) start++; /* Trim leading zeros */
    int result_len = max_len - start;
    TritError err = tritbig_from_trits(temp + start, result_len, result);
    free(temp);
    return err;
}

/* Multiplies two TritBigInt numbers */
TritError tritjs_multiply_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    int max_len = a->len + b->len; /* Max length of product */
    Trit* temp = (Trit*)calloc(max_len, sizeof(Trit)); /* Zero-initialized */
    if (!temp) return TRIT_ERR_MEM;
    for (int i = a->len - 1; i >= 0; i--) {
        int carry = 0;
        for (int j = b->len - 1; j >= 0; j--) {
            int pos = i + j + 1; /* Position in result */
            TritProd prod = trit_multiply(a->digits[i], b->digits[j]);
            TritSum sum = trit_add(temp[pos] + carry, prod.value);
            temp[pos] = sum.value;
            carry = sum.carry + prod.carry;
        }
        if (carry) {
            int carry_pos = i;
            TritSum sum = trit_add(temp[carry_pos] + carry, 0);
            temp[carry_pos] = sum.value;
            if (sum.carry) { /* Shift and add carry if needed */
                memmove(temp, temp + 1, max_len * sizeof(Trit));
                temp[0] = sum.carry;
                max_len++;
            }
        }
    }
    int start = 0;
    while (start < max_len - 1 && temp[start] == 0) start++; /* Trim zeros */
    TritError err = tritbig_from_trits(temp + start, max_len - start, result);
    free(temp);
    return err;
}

/* Divides a by b natively in ternary, returning quotient and remainder as TritFloat */
TritError tritjs_divide_big(TritBigInt* a, TritBigInt* b, TritDivResult* result, int precision) {
    if (!a || !b) return TRIT_ERR_INPUT;
    if (precision <= 0 || precision > 10) return TRIT_ERR_PRECISION; /* Limit precision */

    /* Check if divisor is zero by inspecting all trits */
    int b_is_zero = 1;
    for (int i = 0; i < b->len; i++) {
        if (b->digits[i] != 0) {
            b_is_zero = 0;
            break;
        }
    }
    if (b_is_zero) return TRIT_ERR_DIV_ZERO;

    /* Convert inputs to TritFloat for fractional division */
    TritFloat dividend, divisor;
    TritError err;
    if ((err = tritfloat_from_bigint(a, &dividend)) != TRIT_OK) return err;
    if ((err = tritfloat_from_bigint(b, &divisor)) != TRIT_OK) {
        tritfloat_free(dividend);
        return err;
    }

    /* Allocate space for quotient and remainder */
    result->quotient.integer = (Trit*)malloc(a->len * sizeof(Trit));
    if (!result->quotient.integer) {
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return TRIT_ERR_MEM;
    }
    result->quotient.fraction = (Trit*)malloc(precision * sizeof(Trit));
    if (!result->quotient.fraction) {
        free(result->quotient.integer);
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return TRIT_ERR_MEM;
    }
    result->remainder.integer = (Trit*)malloc(b->len * sizeof(Trit));
    if (!result->remainder.integer) {
        free(result->quotient.integer);
        free(result->quotient.fraction);
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return TRIT_ERR_MEM;
    }
    result->remainder.fraction = NULL; /* Remainder has no fraction initially */
    result->quotient.i_len = a->len;
    result->quotient.f_len = precision;
    result->remainder.i_len = b->len;
    result->remainder.f_len = 0;

    /* Initialize quotient and remainder */
    memset(result->quotient.integer, 0, a->len * sizeof(Trit));
    memset(result->quotient.fraction, 0, precision * sizeof(Trit));
    memcpy(result->remainder.integer, a->digits, a->len * sizeof(Trit));

    /* Integer division */
    for (int i = 0; i < a->len; i++) {
        int digit = 0;
        TritBigInt* temp_rem = NULL;
        if ((err = tritbig_from_trits(result->remainder.integer, result->remainder.i_len, &temp_rem)) != TRIT_OK) {
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return err;
        }
        while (1) { /* Repeatedly subtract divisor */
            TritBigInt* temp_sub;
            if ((err = tritjs_subtract_big(temp_rem, b, &temp_sub)) != TRIT_OK) {
                if (err == TRIT_ERR_NEGATIVE) break; /* Subtraction failed, digit done */
                tritbig_free(temp_rem);
                tritfloat_free(result->quotient);
                tritfloat_free(result->remainder);
                tritfloat_free(dividend);
                tritfloat_free(divisor);
                return err;
            }
            tritbig_free(temp_rem);
            temp_rem = temp_sub;
            digit++;
        }
        result->quotient.integer[i] = digit;
        memcpy(result->remainder.integer, temp_rem->digits, temp_rem->len * sizeof(Trit));
        result->remainder.i_len = temp_rem->len;
        tritbig_free(temp_rem);
    }

    /* Fractional division (up to precision) */
    for (int i = 0; i < precision; i++) {
        TritBigInt* temp_rem = NULL;
        if ((err = tritbig_from_trits(result->remainder.integer, result->remainder.i_len, &temp_rem)) != TRIT_OK) {
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return err;
        }
        /* Multiply remainder by 3 (shift left in base-3) */
        TritBigInt* temp_shift;
        if ((err = tritbig_from_trits((Trit[]){1}, 1, &temp_shift)) != TRIT_OK) {
            tritbig_free(temp_rem);
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return err;
        }
        TritBigInt* temp_mul;
        if ((err = tritjs_multiply_big(temp_rem, temp_shift, &temp_mul)) != TRIT_OK) {
            tritbig_free(temp_rem);
            tritbig_free(temp_shift);
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return err;
        }
        tritbig_free(temp_rem);
        tritbig_free(temp_shift);
        temp_rem = temp_mul;

        int digit = 0;
        while (1) {
            TritBigInt* temp_sub;
            if ((err = tritjs_subtract_big(temp_rem, b, &temp_sub)) != TRIT_OK) {
                if (err == TRIT_ERR_NEGATIVE) break; /* Subtraction failed, digit done */
                tritbig_free(temp_rem);
                tritfloat_free(result->quotient);
                tritfloat_free(result->remainder);
                tritfloat_free(dividend);
                tritfloat_free(divisor);
                return err;
            }
            tritbig_free(temp_rem);
            temp_rem = temp_sub;
            digit++;
        }
        result->quotient.fraction[i] = digit;
        memcpy(result->remainder.integer, temp_rem->digits, temp_rem->len * sizeof(Trit));
        result->remainder.i_len = temp_rem->len;
        tritbig_free(temp_rem);
    }

    /* Trim leading zeros in quotient */
    int int_start = 0;
    while (int_start < result->quotient.i_len - 1 && result->quotient.integer[int_start] == 0) int_start++;
    if (int_start > 0) {
        Trit* new_int = (Trit*)malloc((result->quotient.i_len - int_start) * sizeof(Trit));
        if (!new_int) {
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return TRIT_ERR_MEM;
        }
        memcpy(new_int, result->quotient.integer + int_start, (result->quotient.i_len - int_start) * sizeof(Trit));
        free(result->quotient.integer);
        result->quotient.integer = new_int;
        result->quotient.i_len -= int_start;
    }

    tritfloat_free(dividend);
    tritfloat_free(divisor);
    return TRIT_OK;
}

@*1 Scientific Operations.
Scientific functions use `TritFloat` for precision and `TritBigInt` for large numbers, with refined error handling.

@c
/* Raises base to exp (TritBigInt) */
TritError tritjs_power_big(TritBigInt* base, TritBigInt* exp, TritBigInt** result) {
    if (!base || !exp) return TRIT_ERR_INPUT;
    TritError err;
    if ((err = tritbig_from_trits((Trit[]){1}, 1, result)) != TRIT_OK) return err;
    unsigned long exp_bin;
    if ((err = trits_to_binary(exp->digits, exp->len, &exp_bin)) != TRIT_OK) {
        tritbig_free(*result);
        return err;
    }
    if (exp_bin > 1000) { /* Prevent excessive computation */
        tritbig_free(*result);
        return TRIT_ERR_OVERFLOW;
    }
    for (unsigned long i = 0; i < exp_bin; i++) {
        TritBigInt* temp;
        if ((err = tritjs_multiply_big(*result, base, &temp)) != TRIT_OK) {
            tritbig_free(*result);
            return err;
        }
        tritbig_free(*result);
        *result = temp;
    }
    return TRIT_OK;
}

/* Computes square root as a TritFloat */
TritError tritjs_sqrt_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    if (a_bin == 0) { /* Special case: sqrt(0) = 0 */
        result->integer = (Trit*)malloc(1 * sizeof(Trit));
        if (!result->integer) return TRIT_ERR_MEM;
        result->integer[0] = 0;
        result->i_len = 1;
        result->fraction = (Trit*)malloc(precision * sizeof(Trit));
        if (!result->fraction) {
            free(result->integer);
            return TRIT_ERR_MEM;
        }
        memset(result->fraction, 0, precision * sizeof(Trit));
        result->f_len = precision;
        return TRIT_OK;
    }
    double sqrt_val = sqrt((double)a_bin);
    unsigned long int_part = (unsigned long)sqrt_val;
    double frac_part = sqrt_val - int_part;
    if ((err = binary_to_trits(int_part, (a->len + 1) / 2, &result->integer)) != TRIT_OK) return err;
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        return err;
    }
    result->i_len = (a->len + 1) / 2;
    result->f_len = precision;
    return TRIT_OK;
}

/* Computes base-3 logarithm as a TritFloat */
TritError tritjs_log3_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    if (a_bin <= 0) return TRIT_ERR_UNDEFINED; /* Log of non-positive is undefined */
    double log_val = log((double)a_bin) / log(3.0);
    unsigned long int_part = (unsigned long)log_val;
    double frac_part = log_val - int_part;
    if ((err = binary_to_trits(int_part, a->len, &result->integer)) != TRIT_OK) return err;
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        return err;
    }
    result->i_len = a->len;
    result->f_len = precision;
    return TRIT_OK;
}

/* Computes sine as a TritFloat, scaled with ternary π */
TritError tritjs_sin_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    int pi_len;
    Trit* pi;
    if ((err = tritjs_pi(&pi_len, &pi)) != TRIT_OK) return err;
    unsigned long pi_bin;
    if ((err = trits_to_binary(pi, pi_len, &pi_bin)) != TRIT_OK) {
        free(pi);
        return err;
    }
    double a_rad = (double)a_bin * M_PI / (double)pi_bin; /* Scale to radians */
    double sin_val = sin(a_rad);
    int sign = (sin_val < 0) ? -1 : 1;
    double abs_val = fabs(sin_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;
    if ((err = binary_to_trits(int_part, 1, &result->integer)) != TRIT_OK) {
        free(pi);
        return err;
    }
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        free(pi);
        return err;
    }
    result->i_len = 1;
    result->f_len = precision;
    if (sign < 0) { /* Handle negative result */
        Trit zero[] = {0};
        TritBigInt* zero_bi;
        TritBigInt* neg_int;
        if ((err = tritbig_from_trits(zero, 1, &zero_bi)) != TRIT_OK) {
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        if ((err = tritbig_from_trits(result->integer, result->i_len, &neg_int)) != TRIT_OK) {
            tritbig_free(zero_bi);
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        TritBigInt* temp;
        if ((err = tritjs_subtract_big(zero_bi, neg_int, &temp)) != TRIT_OK) {
            tritbig_free(zero_bi);
            tritbig_free(neg_int);
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        free(result->integer);
        result->integer = temp->digits;
        result->i_len = temp->len;
        tritbig_free(temp);
        tritbig_free(zero_bi);
        tritbig_free(neg_int);
    }
    free(pi);
    return TRIT_OK;
}

/* Computes cosine as a TritFloat, scaled with ternary π */
TritError tritjs_cos_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    int pi_len;
    Trit* pi;
    if ((err = tritjs_pi(&pi_len, &pi)) != TRIT_OK) return err;
    unsigned long pi_bin;
    if ((err = trits_to_binary(pi, pi_len, &pi_bin)) != TRIT_OK) {
        free(pi);
        return err;
    }
    double a_rad = (double)a_bin * M_PI / (double)pi_bin; /* Scale to radians */
    double cos_val = cos(a_rad);
    int sign = (cos_val < 0) ? -1 : 1;
    double abs_val = fabs(cos_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;
    if ((err = binary_to_trits(int_part, 1, &result->integer)) != TRIT_OK) {
        free(pi);
        return err;
    }
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        free(pi);
        return err;
    }
    result->i_len = 1;
    result->f_len = precision;
    if (sign < 0) { /* Handle negative result */
        Trit zero[] = {0};
        TritBigInt* zero_bi;
        TritBigInt* neg_int;
        if ((err = tritbig_from_trits(zero, 1, &zero_bi)) != TRIT_OK) {
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        if ((err = tritbig_from_trits(result->integer, result->i_len, &neg_int)) != TRIT_OK) {
            tritbig_free(zero_bi);
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        TritBigInt* temp;
        if ((err = tritjs_subtract_big(zero_bi, neg_int, &temp)) != TRIT_OK) {
            tritbig_free(zero_bi);
            tritbig_free(neg_int);
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        free(result->integer);
        result->integer = temp->digits;
        result->i_len = temp->len;
        tritbig_free(temp);
        tritbig_free(zero_bi);
        tritbig_free(neg_int);
    }
    free(pi);
    return TRIT_OK;
}

/* Computes tangent as a TritFloat, scaled with ternary π */
TritError tritjs_tan_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    int pi_len;
    Trit* pi;
    if ((err = tritjs_pi(&pi_len, &pi)) != TRIT_OK) return err;
    unsigned long pi_bin;
    if ((err = trits_to_binary(pi, pi_len, &pi_bin)) != TRIT_OK) {
        free(pi);
        return err;
    }
    double a_rad = (double)a_bin * M_PI / (double)pi_bin; /* Scale to radians */
    double tan_val = tan(a_rad);
    if (fabs(tan_val) > 1000.0) { /* Check for asymptotic behavior */
        free(pi);
        return TRIT_ERR_UNDEFINED;
    }
    int sign = (tan_val < 0) ? -1 : 1;
    double abs_val = fabs(tan_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;
    if ((err = binary_to_trits(int_part, (int)log(abs_val)/log(3) + 1, &result->integer)) != TRIT_OK) {
        free(pi);
        return err;
    }
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        free(pi);
        return err;
    }
    result->i_len = (int)log(abs_val)/log(3) + 1;
    result->f_len = precision;
    if (sign < 0) { /* Handle negative result */
        Trit zero[] = {0};
        TritBigInt* zero_bi;
        TritBigInt* neg_int;
        if ((err = tritbig_from_trits(zero, 1, &zero_bi)) != TRIT_OK) {
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        if ((err = tritbig_from_trits(result->integer, result->i_len, &neg_int)) != TRIT_OK) {
            tritbig_free(zero_bi);
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        TritBigInt* temp;
        if ((err = tritjs_subtract_big(zero_bi, neg_int, &temp)) != TRIT_OK) {
            tritbig_free(zero_bi);
            tritbig_free(neg_int);
            tritfloat_free(*result);
            free(pi);
            return err;
        }
        free(result->integer);
        result->integer = temp->digits;
        result->i_len = temp->len;
        tritbig_free(temp);
        tritbig_free(zero_bi);
        tritbig_free(neg_int);
    }
    free(pi);
    return TRIT_OK;
}

/* Computes factorial of a TritBigInt */
TritError tritjs_factorial_big(TritBigInt* a, TritBigInt** result) {
    if (!a) return TRIT_ERR_INPUT;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    if (a_bin > 20) return TRIT_ERR_OVERFLOW; /* Limit to prevent overflow */
    if ((err = tritbig_from_trits((Trit[]){1}, 1, result)) != TRIT_OK) return err;
    for (unsigned long i = 1; i <= a_bin; i++) {
        Trit* i_trits;
        if ((err = binary_to_trits(i, 2, &i_trits)) != TRIT_OK) {
            tritbig_free(*result);
            return err;
        }
        TritBigInt* i_bi;
        if ((err = tritbig_from_trits(i_trits, 2, &i_bi)) != TRIT_OK) {
            free(i_trits);
            tritbig_free(*result);
            return err;
        }
        free(i_trits);
        TritBigInt* temp;
        if ((err = tritjs_multiply_big(*result, i_bi, &temp)) != TRIT_OK) {
            tritbig_free(i_bi);
            tritbig_free(*result);
            return err;
        }
        tritbig_free(*result);
        tritbig_free(i_bi);
        *result = temp;
    }
    return TRIT_OK;
}

/* Returns a ternary approximation of π */
TritError tritjs_pi(int* len, Trit** pi) {
    Trit pi_val[] = {1, 0, 0, 1, 0, 2, 2, 1}; /* π ≈ 3.14159₁₀ ≈ 10.010221₃ */
    *len = 8;
    *pi = (Trit*)malloc(*len * sizeof(Trit));
    if (!*pi) return TRIT_ERR_MEM;
    memcpy(*pi, pi_val, *len * sizeof(Trit));
    return TRIT_OK;
}

@*1 Utility Functions.
String conversion functions for output, with error handling.

@c
/* Converts a trit array to a string */
TritError tritjs_to_string(Trit* trits, int len, char** str) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT;
    *str = (char*)malloc(len + 1);
    if (!*str) return TRIT_ERR_MEM;
    for (int i = 0; i < len; i++) (*str)[i] = '0' + trits[i]; /* Convert to char */
    (*str)[len] = '\0';
    return TRIT_OK;
}

/* Converts a TritFloat to a string (e.g., "1.221") */
TritError tritfloat_to_string(TritFloat tf, char** str) {
    if (!tf.integer || tf.i_len <= 0) return TRIT_ERR_INPUT;
    char* int_str;
    TritError err;
    if ((err = tritjs_to_string(tf.integer, tf.i_len, &int_str)) != TRIT_OK) return err;
    if (tf.f_len == 0) { /* No fractional part */
        *str = int_str;
        return TRIT_OK;
    }
    char* frac_str;
    if ((err = tritjs_to_string(tf.fraction, tf.f_len, &frac_str)) != TRIT_OK) {
        free(int_str);
        return err;
    }
    *str = (char*)malloc(tf.i_len + tf.f_len + 2); /* Space for integer, dot, fraction, null */
    if (!*str) {
        free(int_str);
        free(frac_str);
        return TRIT_ERR_MEM;
    }
    sprintf(*str, "%s.%s", int_str, frac_str); /* Combine with decimal point */
    free(int_str);
    free(frac_str);
    return TRIT_OK;
}

@*1 CLI Functions.
Interactive CLI with error handling, now including cos, tan, and fact, and improved division.

@c
/* Parses a string (e.g., "12") into a TritBigInt */
TritError parse_trit_string(const char* str, TritBigInt** bi) {
    if (!str || strlen(str) == 0) return TRIT_ERR_INPUT; /* Check for empty/null */
    int len = strlen(str);
    Trit* trits = (Trit*)malloc(len * sizeof(Trit));
    if (!trits) return TRIT_ERR_MEM;
    for (int i = 0; i < len; i++) {
        if (str[i] < '0' || str[i] > '2') { /* Validate trit digits */
            free(trits);
            return TRIT_ERR_INPUT;
        }
        trits[i] = str[i] - '0';
    }
    TritError err = tritbig_from_trits(trits, len, bi);
    free(trits);
    return err;
}

/* Main calculator loop, processes user commands */
void run_calculator() {
    char input[256];
    printf("TritJS Ternary Calculator (enter 'quit' to exit)\n");
    printf("Commands: add/sub/mul/div/pow/sqrt/log3/sin/cos/tan/fact/pi <arg1> [arg2]\n");
    while (1) {
        printf("> ");
        if (!fgets(input, 256, stdin)) break; /* Read input, exit on EOF */
        input[strcspn(input, "\n")] = 0; /* Remove newline */
        if (strcmp(input, "quit") == 0) break;

        char op[10], arg1[20], arg2[20] = ""; /* Parse command and arguments */
        int parsed = sscanf(input, "%9s %19s %19s", op, arg1, arg2);
        if (parsed < 2) {
            printf("Error: Invalid command format (e.g., 'add 12 2')\n");
            continue;
        }

        TritBigInt* a = NULL;
        TritBigInt* b = NULL;
        TritError err;

        if ((err = parse_trit_string(arg1, &a)) != TRIT_OK) { /* Parse first argument */
            printf("Error with arg1: %s\n", trit_error_str(err));
            continue;
        }
        if (strlen(arg2) > 0) { /* Parse second argument if provided */
            if ((err = parse_trit_string(arg2, &b)) != TRIT_OK) {
                printf("Error with arg2: %s\n", trit_error_str(err));
                tritbig_free(a);
                continue;
            }
        }

        /* Handle commands */
        if (strcmp(op, "add") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_add_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "sub") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_subtract_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "mul") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_multiply_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "div") == 0 && b) {
            TritDivResult result;
            if ((err = tritjs_divide_big(a, b, &result, 3)) != TRIT_OK) { /* 3-trit precision */
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* q_str;
                char* r_str;
                if ((err = tritfloat_to_string(result.quotient, &q_str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else if ((err = tritfloat_to_string(result.remainder, &r_str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                    free(q_str);
                } else {
                    printf("%s r %s\n", q_str, r_str);
                    free(q_str);
                    free(r_str);
                }
                tritfloat_free(result.quotient);
                tritfloat_free(result.remainder);
            }
        } else if (strcmp(op, "pow") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_power_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "sqrt") == 0) {
            TritFloat result;
            if ((err = tritjs_sqrt_float(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritfloat_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritfloat_free(result);
            }
        } else if (strcmp(op, "log3") == 0) {
            TritFloat result;
            if ((err = tritjs_log3_float(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritfloat_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritfloat_free(result);
            }
        } else if (strcmp(op, "sin") == 0) {
            TritFloat result;
            if ((err = tritjs_sin_float(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritfloat_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritfloat_free(result);
            }
        } else if (strcmp(op, "cos") == 0) {
            TritFloat result;
            if ((err = tritjs_cos_float(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritfloat_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritfloat_free(result);
            }
        } else if (strcmp(op, "tan") == 0) {
            TritFloat result;
            if ((err = tritjs_tan_float(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritfloat_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritfloat_free(result);
            }
        } else if (strcmp(op, "fact") == 0) {
            TritBigInt* result;
            if ((err = tritjs_factorial_big(a, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "pi") == 0) {
            int len;
            Trit* pi;
            if ((err = tritjs_pi(&len, &pi)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(pi, len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                free(pi);
            }
        } else {
            printf("Error: Unknown command or missing argument\n");
        }

        tritbig_free(a);
        if (b) tritbig_free(b);
    }
}

@*1 Main Function.
Entry point, launches the interactive calculator.

@c
int main() {
    run_calculator();
    return 0;
}
