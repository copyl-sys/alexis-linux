@* TritJS-CISA: A Ternary Calculator for Cybersecurity Applications.
This document defines \.{TritJS-CISA}, an advanced ternary (base-3) scientific calculator
designed for the Cybersecurity and Infrastructure Security Agency (CISA). Built in C and
shipped as a \.{.cweb} literate program, it emulates ternary computation on binary hardware,
optimized for cybersecurity tasks such as trit-based encoding, cryptographic analysis, or
educational tools for secure system design. Originally adapted from a JavaScript module,
this version enhances the original TritJS with:

- **Memory-Mapped Files**: Leveraging \.{mmap} for efficient handling of large trit arrays,
  reducing memory overhead in high-precision operations.
- **Security Hardening**: Comprehensive error handling, audit logging to \.{/var/log/tritjs_cisa.log},
  and memory safety to meet government security standards.
- **Complex Arithmetic**: Support for fractional numbers (\.{TritFloat}), arbitrary-precision integers
  (\.{TritBigInt}), and complex numbers (\.{TritComplex}).
- **Scientific Functions**: Includes exponentiation, square roots, base-3 logarithms, trigonometric
  functions, and factorials, all in ternary.
- **Interactive CLI**: A command-line interface with CISA-specific auditing and help documentation.

This tool is intended for use in secure environments, prioritizing performance, precision,
and traceability. The current date is March 01, 2025, and this version reflects continuous
updates for reliability.

@*1 Usage and Documentation.
To compile and run:
- Use \.{cweave tritjs_cisa.cweb} to generate documentation (\.{tritjs_cisa.tex}).
- Use \.{ctangle tritjs_cisa.cweb} to extract the C code (\.{tritjs_cisa.c}).
- Compile with \.{gcc -o tritjs_cisa tritjs_cisa.c -lm}.
- Run \.{./tritjs_cisa} to launch the CLI.

Commands follow the format: \.{<operation> <arg1> [arg2]}, e.g., \.{add 12 2}.
Supported operations include:
- Arithmetic: \.{add}, \.{sub}, \.{mul}, \.{div}, \.{pow}, \.{fact}
- Scientific: \.{sqrt}, \.{log3}, \.{sin}, \.{cos}, \.{tan}, \.{pi}
- General: \.{help}, \.{quit}

All inputs are in base-3 (trits: 0, 1, 2). Outputs are logged for auditing, and memory-mapped
files are stored temporarily in a secure location.

@*1 Implementation.
Below is the refactored C code with all operations implemented.

@c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>

#define TRIT_MAX 3
#define MAX_MMAP_SIZE (1024 * 1024) /* 1MB limit */

/* Prototypes */
TritError tritjs_add_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b || a->len > 1000 || b->len > 1000) return TRIT_ERR_INPUT; /* Arbitrary cap */
    int max_len = (a->len > b->len) ? a->len : b->len;
    Trit* temp = calloc(max_len + 1, sizeof(Trit));
    if (!temp) return TRIT_ERR_MEM;
    /* Rest unchanged */
}
TritError tritjs_subtract_big(TritBigInt* a, TritBigInit* b, TritBigInt** result);
TritError tritjs_multiply_big(TritBigInt* a, TritBigInit* b, TritBigInt** result);
TritError tritjs_divide_big(TritBigInt* a, TritBigInt* b, TritDivResult* result, int precision) {
    /* Existing checks and setup */
    TritBigInt* temp_rem = NULL;
    if ((err = tritbig_from_trits(a->digits, a->len, a->sign, &temp_rem)) != TRIT_OK) goto cleanup;

    for (int i = 0; i < a->len; i++) {
        int digit = 0;
        TritBigInt* multiple = NULL, *prod = NULL, *sub = NULL;
        for (int q = 2; q >= 0; q--) {
            Trit trits[] = {(Trit)q};
            if ((err = tritbig_from_trits(trits, 1, 0, &multiple)) != TRIT_OK) goto loop_cleanup;
            if ((err = tritjs_multiply_big(b, multiple, &prod)) != TRIT_OK) {
                tritbig_free(multiple);
                goto loop_cleanup;
            }
            if ((err = tritjs_subtract_big(temp_rem, prod, &sub)) == TRIT_OK) {
                digit = q;
                tritbig_free(temp_rem);
                temp_rem = sub;
                tritbig_free(multiple);
                tritbig_free(prod);
                break;
            }
            tritbig_free(multiple);
            tritbig_free(prod);
        }
        result->quotient.integer[i] = digit;
    loop_cleanup:
        if (err != TRIT_OK) {
            cleanup_div(temp_rem, Ã·nd, &divisor, result);
            return err;
        }
    }
    /* Fractional part and cleanup as before */
}
TritError tritjs_sqrt_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10 || a->len > 1000) return TRIT_ERR_PRECISION;
    unsigned long a_bin = 0;
    for (int i = 0; i < a->len; i++) {
        if (a_bin > ULONG_MAX / TRIT_MAX) return TRIT_ERR_OVERFLOW;
        a_bin = a_bin * TRIT_MAX + a->digits[i];
    }
    double a_val = (double)a_bin * (a->sign ? -1 : 1);
    /* Negative case */
    if (a_val < 0) {
        double sqrt_val = sqrt(-a_val);
        unsigned long int_part = (unsigned long)sqrt_val;
        double frac_part = sqrt_val - int_part;
        result->real.integer = calloc(1, sizeof(Trit));
        if (!result->real.integer) return TRIT_ERR_MEM;
        /* Rest as before */
    }
    /* Positive case unchanged */
}

/* Need to identify missing /

@*2 Error Handling.
Enhanced with memory mapping errors and audit logging.

@d TritError int
@d TRIT_OK 0
@d TRIT_ERR_MEM 1
@d TRIT_ERR_INPUT 2
@d TRIT_ERR_DIV_ZERO 3
@d TRIT_ERR_OVERFLOW 4
@d TRIT_ERR_UNDEFINED 5
@d TRIT_ERR_NEGATIVE 6
@d TRIT_ERR_PRECISION 7
@d TRIT_ERR_MMAP 8

FILE* audit_log = NULL;

void init_audit_log() {
    audit_log = fopen("/var/log/tritjs_cisa.log", "a");
    if (!audit_log) perror("Audit log initialization failed");
}

void log_error(TritError err, const char* context) {
    if (!audit_log) return;
    time_t now;
    time(&now);
    fprintf(audit_log, "[%s] Error %d: %s in %s\n", ctime(&now), err, trit_error_str(err), context);
    fflush(audit_log);
}

const char* trit_error_str(TritError err) {
    switch (err) {
        case TRIT_OK: return "No error";
        case TRIT_ERR_MEM: return "Memory allocation failed";
        case TRIT_ERR_INPUT: return "Invalid input (trits 0-2 only)";
        case TRIT_ERR_DIV_ZERO: return "Division by zero";
        case TRIT_ERR_OVERFLOW: return "Overflow detected";
        case TRIT_ERR_UNDEFINED: return "Operation undefined";
        case TRIT_ERR_NEGATIVE: return "Negative input (complex handled)";
        case TRIT_ERR_PRECISION: return "Precision limit exceeded";
        case TRIT_ERR_MMAP: return "Memory mapping failed";
        default: return "Unknown error";
    }
}

@*2 Data Structures.
Memory-mapped trit arrays for scalability.

typedef int Trit;
typedef struct {
    int sign;            /* 0 = positive, 1 = negative */
    Trit* digits;        /* Memory-mapped trits */
    int len;             /* Number of trits */
    int is_mapped;       /* Flag for mmap cleanup */
    int fd;              /* File descriptor */
} TritBigInt;

typedef struct {
    int sign;
    Trit* integer;       /* Memory-mapped integer part */
    Trit* fraction;      /* Memory-mapped fractional part */
    int i_len, f_len;
    int i_mapped, f_mapped;
    int i_fd, f_fd;
} TritFloat;

typedef struct {
    TritFloat real;
    TritFloat imag;
} TritComplex;

typedef struct {
    TritFloat quotient;
    TritFloat remainder;
} TritDivResult;

TritError map_trits(Trit** digits, int len, int* is_mapped, int* fd) {
    if (len * sizeof(Trit) > MAX_MMAP_SIZE) return TRIT_ERR_OVERFLOW;
    char tmp_path[] = "/tmp/tritjs_cisa_XXXXXX";
    *fd = mkstemp(tmp_path);
    if (*fd < 0) return TRIT_ERR_MMAP;
    ftruncate(*fd, len * sizeof(Trit));
    *digits = mmap(NULL, len * sizeof(Trit), PROT_READ | PROT_WRITE, MAP_SHARED, *fd, 0);
    if (*digits == MAP_FAILED) {
        close(*fd);
        unlink(tmp_path);
        return TRIT_ERR_MMAP;
    }
    *is_mapped = 1;
    unlink(tmp_path); /* Remove file after mapping */
    return TRIT_OK;
}

void unmap_trits(Trit* digits, int len, int is_mapped, int fd) {
    if (is_mapped) {
        munmap(digits, len * sizeof(Trit));
        close(fd);
    } else {
        free(digits);
    }
}

TritError tritbig_from_trits(Trit* trits, int len, int sign, TritBigInt** bi) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT;
    *bi = calloc(1, sizeof(TritBigInt));
    if (!*bi) return TRIT_ERR_MEM;
    TritError err = map_trits(&(*bi)->digits, len, &(*bi)->is_mapped, &(*bi)->fd);
    if (err != TRIT_OK) {
        free(*bi);
        return err;
    }
    memcpy((*bi)->digits, trits, len * sizeof(Trit));
    (*bi)->len = len;
    (*bi)->sign = sign;
    return TRIT_OK;
}

void tritbig_free(TritBigInt* bi) {
    if (bi) {
        unmap_trits(bi->digits, bi->len, bi->is_mapped, bi->fd);
        free(bi);
    }
}

TritError tritfloat_from_bigint(TritBigInt* bi, TritFloat* tf) {
    if (!bi || bi->len <= 0) return TRIT_ERR_INPUT;
    tf->sign = bi->sign;
    tf->i_len = bi->len;
    tf->f_len = 0;
    TritError err = map_trits(&tf->integer, bi->len, &tf->i_mapped, &tf->i_fd);
    if (err != TRIT_OK) return err;
    memcpy(tf->integer, bi->digits, bi->len * sizeof(Trit));
    tf->fraction = NULL;
    tf->f_mapped = 0;
    return TRIT_OK;
}

void tritfloat_free(TritFloat tf) {
    unmap_trits(tf.integer, tf.i_len, tf.i_mapped, tf.i_fd);
    if (tf.f_len > 0) unmap_trits(tf.fraction, tf.f_len, tf.f_mapped, tf.f_fd);
}

TritError tritcomplex_from_float(TritFloat real, TritFloat imag, TritComplex* tc) {
    tc->real = real;
    tc->imag = imag;
    return TRIT_OK;
}

void tritcomplex_free(TritComplex tc) {
    tritfloat_free(tc.real);
    tritfloat_free(tc.imag);
}

@*2 Arithmetic Operations.
Core ternary arithmetic functions.

@c
TritError tritjs_add_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    int max_len = (a->len > b->len) ? a->len : b->len;
    Trit* temp = calloc(max_len + 1, sizeof(Trit));
    if (!temp) return TRIT_ERR_MEM;
    int carry = 0;

    if (a->sign == b->sign) {
        for (int i = max_len - 1, pos = 0; i >= 0; i--, pos++) {
            Trit a_trit = (i < a->len) ? a->digits[i] : 0;
            Trit b_trit = (i < b->len) ? b->digits[i] : 0;
            int sum = a_trit + b_trit + carry;
            temp[max_len - pos] = sum % TRIT_MAX;
            carry = sum / TRIT_MAX;
        }
        if (carry) temp[0] = carry;
        int result_len = carry ? max_len + 1 : max_len;
        if (!carry) memmove(temp, temp + 1, max_len * sizeof(Trit));
        TritError err = tritbig_from_trits(temp, result_len, a->sign, result);
        free(temp);
        return err;
    } else {
        // Handle subtraction-like addition (simplified for brevity)
        TritBigInt* b_neg;
        TritError err = tritbig_from_trits(b->digits, b->len, !b->sign, &b_neg);
        if (err != TRIT_OK) { free(temp); return err; }
        err = tritjs_add_big(a, b_neg, result);
        tritbig_free(b_neg);
        free(temp);
        return err;
    }
}

TritError tritjs_subtract_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    TritBigInt* b_neg;
    TritError err = tritbig_from_trits(b->digits, b->len, !b->sign, &b_neg);
    if (err != TRIT_OK) return err;
    err = tritjs_add_big(a, b_neg, result);
    tritbig_free(b_neg);
    return err;
}

TritError tritjs_multiply_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    int max_len = a->len + b->len;
    Trit* temp = calloc(max_len, sizeof(Trit));
    if (!temp) return TRIT_ERR_MEM;
    for (int i = a->len - 1; i >= 0; i--) {
        int carry = 0;
        for (int j = b->len - 1; j >= 0; j--) {
            int pos = i + j + 1;
            int prod = a->digits[i] * b->digits[j] + temp[pos] + carry;
            temp[pos] = prod % TRIT_MAX;
            carry = prod / TRIT_MAX;
        }
        if (carry) temp[i] += carry;
    }
    int start = 0;
    while (start < max_len - 1 && temp[start] == 0) start++;
    int sign = (a->sign == b->sign) ? 0 : 1;
    TritError err = tritbig_from_trits(temp + start, max_len - start, sign, result);
    free(temp);
    return err;
}

TritError tritjs_divide_big(TritBigInt* a, TritBigInt* b, TritDivResult* result, int precision) {
    if (!a || !b) return TRIT_ERR_INPUT;
    if (precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;

    int b_is_zero = 1;
    for (int i = 0; i < b->len; i++) {
        if (b->digits[i] != 0) { b_is_zero = 0; break; }
    }
    if (b_is_zero) {
        log_error(TRIT_ERR_DIV_ZERO, "tritjs_divide_big");
        return TRIT_ERR_DIV_ZERO;
    }

    TritFloat dividend, divisor;
    TritError err;
    if ((err = tritfloat_from_bigint(a, Ã·nd)) != TRIT_OK) return err;
    if ((err = tritfloat_from_bigint(b, &divisor)) != TRIT_OK) {
        tritfloat_free(dividend);
        return err;
    }

    result->quotient.i_len = a->len;
    result->quotient.f_len = precision;
    result->remainder.i_len = b->len;
    result->quotient.sign = (a->sign == b->sign) ? 0 : 1;
    result->remainder.sign = a->sign;

    if ((err = map_trits(&result->quotient.integer, a->len, &result->quotient.i_mapped, &result->quotient.i_fd)) != TRIT_OK) goto cleanup;
    if ((err = map_trits(&result->quotient.fraction, precision, &result->quotient.f_mapped, &result->quotient.f_fd)) != TRIT_OK) goto cleanup;
    if ((err = map_trits(&result->remainder.integer, b->len, &result->remainder.i_mapped, &result->remainder.i_fd)) != TRIT_OK) goto cleanup;

    TritBigInt* temp_rem;
    if ((err = tritbig_from_trits(a->digits, a->len, a->sign, &temp_rem)) != TRIT_OK) goto cleanup;

    for (int i = 0; i < a->len; i++) {
        int digit = 0;
        for (int q = 2; q >= 0; q--) {
            TritBigInt* multiple;
            Trit trits[] = {(Trit)q};
            if ((err = tritbig_from_trits(trits, 1, 0, &multiple)) != TRIT_OK) goto cleanup_inner;
            TritBigInt* prod;
            if ((err = tritjs_multiply_big(b, multiple, &prod)) != TRIT_OK) {
                tritbig_free(multiple);
                goto cleanup_inner;
            }
            TritBigInt* sub;
            if ((err = tritjs_subtract_big(temp_rem, prod, &sub)) == TRIT_OK) {
                digit = q;
                tritbig_free(temp_rem);
                temp_rem = sub;
                tritbig_free(multiple);
                tritbig_free(prod);
                break;
            }
            tritbig_free(multiple);
            tritbig_free(prod);
        }
        result->quotient.integer[i] = digit;
    }

    for (int i = 0; i < precision; i++) {
        TritBigInt* three;
        if ((err = tritbig_from_trits((Trit[]){1}, 1, 0, &three)) != TRIT_OK) goto cleanup_inner;
        TritBigInt* temp_mul;
        if ((err = tritjs_multiply_big(temp_rem, three, &temp_mul)) != TRIT_OK) {
            tritbig_free(three);
            goto cleanup_inner;
        }
        tritbig_free(temp_rem);
        temp_rem = temp_mul;
        int digit = 0;
        for (int q = 2; q >= 0; q--) {
            TritBigInt* multiple;
            Trit trits[] = {(Trit)q};
            if ((err = tritbig_from_trits(trits, 1, 0, &multiple)) != TRIT_OK) goto cleanup_inner;
            TritBigInt* prod;
            if ((err = tritjs_multiply_big(b, multiple, &prod)) != TRIT_OK) {
                tritbig_free(multiple);
                goto cleanup_inner;
            }
            TritBigInt* sub;
            if ((err = tritjs_subtract_big(temp_rem, prod, &sub)) == TRIT_OK) {
                digit = q;
                tritbig_free(temp_rem);
                temp_rem = sub;
                tritbig_free(multiple);
                tritbig_free(prod);
                break;
            }
            tritbig_free(multiple);
            tritbig_free(prod);
        }
        result->quotient.fraction[i] = digit;
    }

    int start = 0;
    while (start < result->quotient.i_len - 1 && result->quotient.integer[start] == 0) start++;
    if (start > 0) {
        memmove(result->quotient.integer, result->quotient.integer + start, (result->quotient.i_len - start) * sizeof(Trit));
        result->quotient.i_len -= start;
    }

cleanup_inner:
    tritbig_free(temp_rem);
cleanup:
    if (err != TRIT_OK) {
        tritfloat_free(result->quotient);
        tritfloat_free(result->remainder);
    }
    tritfloat_free(dividend);
    tritfloat_free(divisor);
    return err;
}

TritError tritjs_power_big(TritBigInt* base, TritBigInt* exp, TritBigInt** result) {
    if (!base || !exp) return TRIT_ERR_INPUT;
    if (exp->sign) return TRIT_ERR_NEGATIVE;
    TritError err;
    Trit trits[] = {1};
    if ((err = tritbig_from_trits(trits, 1, 0, result)) != TRIT_OK) return err;
    unsigned long exp_val = 0;
    for (int i = 0; i < exp->len; i++) exp_val = exp_val * TRIT_MAX + exp->digits[i];
    if (exp_val > 1000) {
        tritbig_free(*result);
        return TRIT_ERR_OVERFLOW;
    }
    int sign = (base->sign && (exp_val % 2)) ? 1 : 0;
    for (unsigned long i = 0; i < exp_val; i++) {
        TritBigInt* temp;
        if ((err = tritjs_multiply_big(*result, base, &temp)) != TRIT_OK) {
            tritbig_free(*result);
            return err;
        }
        tritbig_free(*result);
        *result = temp;
    }
    (*result)->sign = sign;
    return TRIT_OK;
}

TritError tritjs_factorial_big(TritBigInt* a, TritBigInt** result) {
    if (!a) return TRIT_ERR_INPUT;
    if (a->sign) return TRIT_ERR_NEGATIVE;
    unsigned long a_val = 0;
    for (int i = 0; i < a->len; i++) a_val = a_val * TRIT_MAX + a->digits[i];
    if (a_val > 20) return TRIT_ERR_OVERFLOW;
    TritError err;
    Trit trits[] = {1};
    if ((err = tritbig_from_trits(trits, 1, 0, result)) != TRIT_OK) return err;
    for (unsigned long i = 1; i <= a_val; i++) {
        TritBigInt* i_bi;
        Trit i_trits[2];
        i_trits[0] = i / TRIT_MAX; i_trits[1] = i % TRIT_MAX;
        int len = (i >= TRIT_MAX) ? 2 : 1;
        if ((err = tritbig_from_trits(i_trits + (2 - len), len, 0, &i_bi)) != TRIT_OK) {
            tritbig_free(*result);
            return err;
        }
        TritBigInt* temp;
        if ((err = tritjs_multiply_big(*result, i_bi, &temp)) != TRIT_OK) {
            tritbig_free(i_bi);
            tritbig_free(*result);
            return err;
        }
        tritbig_free(*result);
        tritbig_free(i_bi);
        *result = temp;
    }
    return TRIT_OK;
}

@*2 Scientific Operations.
Advanced ternary scientific functions.

@c
TritError tritjs_sqrt_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_val = 0;
    for (int i = 0; i < a->len; i++) a_val = a_val * TRIT_MAX + a->digits[i];
    double val = (double)a_val * (a->sign ? -1 : 1);
    TritError err;
    if (val >= 0) {
        double sqrt_val = sqrt(val);
        unsigned long int_part = (unsigned long)sqrt_val;
        double frac_part = sqrt_val - int_part;
        Trit* int_trits = calloc((a->len + 1) / 2, sizeof(Trit));
        Trit* frac_trits = calloc(precision, sizeof(Trit));
        if (!int_trits || !frac_trits) {
            free(int_trits); free(frac_trits);
            return TRIT_ERR_MEM;
        }
        for (int i = (a->len + 1) / 2 - 1; i >= 0; i--) {
            int_trits[i] = int_part % TRIT_MAX;
            int_part /= TRIT_MAX;
        }
        for (int i = precision - 1; i >= 0; i--) {
            frac_part *= TRIT_MAX;
            frac_trits[i] = (unsigned long)frac_part;
            frac_part -= (unsigned long)frac_part;
        }
        TritBigInt* real_int;
        if ((err = tritbig_from_trits(int_trits, (a->len + 1) / 2, 0, &real_int)) != TRIT_OK) goto sqrt_cleanup;
        if ((err = tritfloat_from_bigint(real_int, &result->real)) != TRIT_OK) goto sqrt_cleanup;
        tritbig_free(real_int);
        if ((err = map_trits(&result->real.fraction, precision, &result->real.f_mapped, &result->real.f_fd)) != TRIT_OK) goto sqrt_cleanup;
        memcpy(result->real.fraction, frac_trits, precision * sizeof(Trit));
        result->real.f_len = precision;
        result->imag.integer = calloc(1, sizeof(Trit));
        if (!result->imag.integer) { err = TRIT_ERR_MEM; goto sqrt_cleanup; }
        result->imag.i_len = 1;
        result->imag.i_mapped = 0;
        result->imag.sign = 0;
        result->imag.fraction = NULL;
        result->imag.f_len = 0;
sqrt_cleanup:
        free(int_trits); free(frac_trits);
        if (err != TRIT_OK) tritcomplex_free(*result);
        return err;
    } else {
        double sqrt_val = sqrt(-val);
        unsigned long int_part = (unsigned long)sqrt_val;
        double frac_part = sqrt_val - int_part;
        result->real.integer = calloc(1, sizeof(Trit));
        if (!result->real.integer) return TRIT_ERR_MEM;
        result->real.i_len = 1;
        result->real.i_mapped = 0;
        result->real.sign = 0;
        if ((err = map_trits(&result->real.fraction, precision, &result->real.f_mapped, &result->real.f_fd)) != TRIT_OK) {
            free(result->real.integer);
            return err;
        }
        memset(result->real.fraction, 0, precision * sizeof(Trit));
        result->real.f_len = precision;
        Trit* imag_int = calloc((a->len + 1) / 2, sizeof(Trit));
        Trit* imag_frac = calloc(precision, sizeof(Trit));
        if (!imag_int || !imag_frac) {
            free(imag_int); free(imag_frac);
            tritfloat_free(result->real);
            return TRIT_ERR_MEM;
        }
        for (int i = (a->len + 1) / 2 - 1; i >= 0; i--) {
            imag_int[i] = int_part % TRIT_MAX;
            int_part /= TRIT_MAX;
        }
        for (int i = precision - 1; i >= 0; i--) {
            frac_part *= TRIT_MAX;
            imag_frac[i] = (unsigned long)frac_part;
            frac_part -= (unsigned long)frac_part;
        }
        TritBigInt* imag_bi;
        if ((err = tritbig_from_trits(imag_int, (a->len + 1) / 2, 0, &imag_bi)) != TRIT_OK) {
            free(imag_int); free(imag_frac);
            tritfloat_free(result->real);
            return err;
        }
        if ((err = tritfloat_from_bigint(imag_bi, &result->imag)) != TRIT_OK) {
            tritbig_free(imag_bi);
            free(imag_int); free(imag_frac);
            return err;
        }
        tritbig_free(imag_bi);
        if ((err = map_trits(&result->imag.fraction, precision, &result->imag.f_mapped, &result->imag.f_fd)) != TRIT_OK) {
            free(imag_int); free(imag_frac);
            tritfloat_free(result->real);
            return err;
        }
        memcpy(result->imag.fraction, imag_frac, precision * sizeof(Trit));
        result->imag.f_len = precision;
        free(imag_int); free(imag_frac);
        return TRIT_OK;
    }
}

TritError tritjs_log3_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_val = 0;
    for (int i = 0; i < a->len; i++) a_val = a_val * TRIT_MAX + a->digits[i];
    double real = (double)a_val * (a->sign ? -1 : 1);
    double imag = 0; /* Simplified, assumes real input */
    double mag = sqrt(real * real + imag * imag);
    double arg = atan2(imag, real);
    double ln3 = log(3.0);
    double real_val = log(mag) / ln3;
    double imag_val = arg / ln3;

    TritError err;
    Trit* real_int = calloc(a->len, sizeof(Trit));
    Trit* real_frac = calloc(precision, sizeof(Trit));
    Trit* imag_int = calloc(a->len, sizeof(Trit));
    Trit* imag_frac = calloc(precision, sizeof(Trit));
    if (!real_int || !real_frac || !imag_int || !imag_frac) {
        free(real_int); free(real_frac); free(imag_int); free(imag_frac);
        return TRIT_ERR_MEM;
    }

    unsigned long r_int_part = (unsigned long)fabs(real_val);
    double r_frac_part = fabs(real_val) - r_int_part;
    for (int i = a->len - 1; i >= 0; i--) {
        real_int[i] = r_int_part % TRIT_MAX;
        r_int_part /= TRIT_MAX;
    }
    for (int i = precision - 1; i >= 0; i--) {
        r_frac_part *= TRIT_MAX;
        real_frac[i] = (unsigned long)r_frac_part;
        r_frac_part -= (unsigned long)r_frac_part;
    }
    TritBigInt* real_bi;
    if ((err = tritbig_from_trits(real_int, a->len, real_val < 0 ? 1 : 0, &real_bi)) != TRIT_OK) goto log_cleanup;
    if ((err = tritfloat_from_bigint(real_bi, &result->real)) != TRIT_OK) goto log_cleanup;
    tritbig_free(real_bi);
    if ((err = map_trits(&result->real.fraction, precision, &result->real.f_mapped, &result->real.f_fd)) != TRIT_OK) goto log_cleanup;
    memcpy(result->real.fraction, real_frac, precision * sizeof(Trit));
    result->real.f_len = precision;

    unsigned long i_int_part = (unsigned long)fabs(imag_val);
    double i_frac_part = fabs(imag_val) - i_int_part;
    for (int i = a->len - 1; i >= 0; i--) {
        imag_int[i] = i_int_part % TRIT_MAX;
        i_int_part /= TRIT_MAX;
    }
    for (int i = precision - 1; i >= 0; i--) {
        i_frac_part *= TRIT_MAX;
        imag_frac[i] = (unsigned long)i_frac_part;
        i_frac_part -= (unsigned long)i_frac_part;
    }
    TritBigInt* imag_bi;
    if ((err = tritbig_from_trits(imag_int, a->len, imag_val < 0 ? 1 : 0, &imag_bi)) != TRIT_OK) goto log_cleanup;
    if ((err = tritfloat_from_bigint(imag_bi, &result->imag)) != TRIT_OK) goto log_cleanup;
    tritbig_free(imag_bi);
    if ((err = map_trits(&result->imag.fraction, precision, &result->imag.f_mapped, &result->imag.f_fd)) != TRIT_OK) goto log_cleanup;
    memcpy(result->imag.fraction, imag_frac, precision * sizeof(Trit));
    result->imag.f_len = precision;

log_cleanup:
    free(real_int); free(real_frac); free(imag_int); free(imag_frac);
    if (err != TRIT_OK) tritcomplex_free(*result);
    return err;
}

TritError tritjs_trig_complex(TritBigInt* a, int precision, TritComplex* result, double (*trig_func)(double)) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_val = 0;
    for (int i = 0; i < a->len; i++) a_val = a_val * TRIT_MAX + a->digits[i];
    double pi_approx = 3.1415926535; /* Simplified */
    double angle = (double)a_val * pi_approx / 10.0 * (a->sign ? -1 : 1); /* Rough scaling */
    double trig_val = trig_func(angle);
    int sign = trig_val < 0 ? 1 : 0;
    double abs_val = fabs(trig_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;

    TritError err;
    Trit* int_trits = calloc(1, sizeof(Trit));
    Trit* frac_trits = calloc(precision, sizeof(Trit));
    if (!int_trits || !frac_trits) {
        free(int_trits); free(frac_trits);
        return TRIT_ERR_MEM;
    }
    int_trits[0] = int_part % TRIT_MAX;
    for (int i = precision - 1; i >= 0; i--) {
        frac_part *= TRIT_MAX;
        frac_trits[i] = (unsigned long)frac_part;
        frac_part -= (unsigned long)frac_part;
    }
    TritBigInt* real_bi;
    if ((err = tritbig_from_trits(int_trits, 1, sign, &real_bi)) != TRIT_OK) goto trig_cleanup;
    if ((err = tritfloat_from_bigint(real_bi, &result->real)) != TRIT_OK) goto trig_cleanup;
    tritbig_free(real_bi);
    if ((err = map_trits(&result->real.fraction, precision, &result->real.f_mapped, &result->real.f_fd)) != TRIT_OK) goto trig_cleanup;
    memcpy(result->real.fraction, frac_trits, precision * sizeof(Trit));
    result->real.f_len = precision;
    result->imag.integer = calloc(1, sizeof(Trit));
    if (!result->imag.integer) { err = TRIT_ERR_MEM; goto trig_cleanup; }
    result->imag.i_len = 1;
    result->imag.i_mapped = 0;
    result->imag.sign = 0;
    result->imag.fraction = NULL;
    result->imag.f_len = 0;

trig_cleanup:
    free(int_trits); free(frac_trits);
    if (err != TRIT_OK) tritcomplex_free(*result);
    return err;
}

TritError tritjs_sin_complex(TritBigInt* a, int precision, TritComplex* result) {
    return tritjs_trig_complex(a, precision, result, sin);
}

TritError tritjs_cos_complex(TritBigInt* a, int precision, TritComplex* result) {
    return tritjs_trig_complex(a, precision, result, cos);
}

TritError tritjs_tan_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_val = 0;
    for (int i = 0; i < a->len; i++) a_val = a_val * TRIT_MAX + a->digits[i];
    double pi_approx = 3.1415926535;
    double angle = (double)a_val * pi_approx / 10.0 * (a->sign ? -1 : 1);
    double tan_val = tan(angle);
    if (fabs(tan_val) > 1000.0) return TRIT_ERR_UNDEFINED;
    return tritjs_trig_complex(a, precision, result, tan);
}

TritError tritjs_pi(int* len, Trit** pi) {
    Trit pi_val[] = {1, 0, 0, 1, 0, 2, 2, 1}; /* Approximation */
    *len = 8;
    *pi = malloc(*len * sizeof(Trit));
    if (!*pi) return TRIT_ERR_MEM;
    memcpy(*pi, pi_val, *len * sizeof(Trit));
    return TRIT_OK;
}

@*2 Utility Functions.
String conversion for output.

@c
TritError tritjs_to_string(TritBigInt* bi, char** str) {
    if (!bi || bi->len <= 0) return TRIT_ERR_INPUT;
    *str = malloc(bi->len + 1 + (bi->sign ? 1 : 0));
    if (!*str) return TRIT_ERR_MEM;
    char* p = *str;
    if (bi->sign) *p++ = '-';
    for (int i = 0; i < bi->len; i++) *p++ = '0' + bi->digits[i];
    *p = '\0';
    return TRIT_OK;
}

TritError tritfloat_to_string(TritFloat tf, char** str) {
    if (!tf.integer || tf.i_len <= 0) return TRIT_ERR_INPUT;
    int total_len = tf.i_len + (tf.f_len > 0 ? tf.f_len + 1 : 0) + (tf.sign ? 1 : 0);
    *str = malloc(total_len + 1);
    if (!*str) return TRIT_ERR_MEM;
    char* p = *str;
    if (tf.sign) *p++ = '-';
    for (int i = 0; i < tf.i_len; i++) *p++ = '0' + tf.integer[i];
    if (tf.f_len > 0) {
        *p++ = '.';
        for (int i = 0; i < tf.f_len; i++) *p++ = '0' + tf.fraction[i];
    }
    *p = '\0';
    return TRIT_OK;
}

TritError tritcomplex_to_string(TritComplex tc, char** str) {
    char* real_str, *imag_str;
    TritError err;
    if ((err = tritfloat_to_string(tc.real, &real_str)) != TRIT_OK) return err;
    if ((err = tritfloat_to_string(tc.imag, &imag_str)) != TRIT_OK) {
        free(real_str);
        return err;
    }
    int imag_zero = (tc.imag.i_len == 1 && tc.imag.integer[0] == 0 && tc.imag.f_len == 0);
    if (imag_zero) {
        *str = real_str;
        free(imag_str);
        return TRIT_OK;
    }
    *str = malloc(strlen(real_str) + strlen(imag_str) + 4);
    if (!*str) {
        free(real_str);
        free(imag_str);
        return TRIT_ERR_MEM;
    }
    sprintf(*str, "%s %si", real_str, imag_str);
    free(real_str);
    free(imag_str);
    return TRIT_OK;
}

@*2 CLI for CISA.
Fully implemented with all operations.

@c
TritError parse_trit_string(const char* str, TritBigInt** bi) {
    if (!str || !strlen(str)) return TRIT_ERR_INPUT;
    int sign = (str[0] == '-') ? 1 : 0;
    const char* mag = sign ? str + 1 : str;
    int len = strlen(mag);
    Trit* trits = malloc(len * sizeof(Trit));
    if (!trits) return TRIT_ERR_MEM;
    for (int i = 0; i < len; i++) {
        if (mag[i] < '0' || mag[i] > '2') {
            free(trits);
            return TRIT_ERR_INPUT;
        }
        trits[i] = mag[i] - '0';
    }
    TritError err = tritbig_from_trits(trits, len, sign, bi);
    free(trits);
    return err;
}

void print_help() {
    printf("\nTritJS-CISA Commands:\n");
    printf("  add <a> <b> - Addition\n");
    printf("  sub <a> <b> - Subtraction\n");
    printf("  mul <a> <b> - Multiplication\n");
    printf("  div <a> <b> - Division\n");
    printf("  pow <a> <b> - Exponentiation\n");
    printf("  fact <a>    - Factorial\n");
    printf("  sqrt <a>    - Square Root\n");
    printf("  log3 <a>    - Base-3 Logarithm\n");
    printf("  sin <a>     - Sine\n");
    printf("  cos <a>     - Cosine\n");
    printf("  tan <a>     - Tangent\n");
    printf("  pi          - Pi in base-3\n");
    printf("  help        - Show this help\n");
    printf("  quit        - Exit\n");
}

void run_calculator() {
    init_audit_log();
    char input[256];
    printf("TritJS-CISA Ternary Calculator (quit to exit)\n");
    while (1) {
        printf("> ");
        if (!fgets(input, 256, stdin)) break;
        input[strcspn(input, "\n")] = 0;
        if (audit_log) fprintf(audit_log, "[%ld] Command: %s\n", time(NULL), input);
        if (strcmp(input, "quit") == 0) break;
        if (strcmp(input, "help") == 0) {
            print_help();
            continue;
        }

        char op[10], arg1[20], arg2[20] = "";
        int parsed = sscanf(input, "%9s %19s %19s", op, arg1, arg2);
        if (parsed < 2) {
            printf("Error: Invalid format\n");
            continue;
        }

        TritBigInt* a = NULL;
        TritBigInt* b = NULL;
        TritError err;
        if ((err = parse_trit_string(arg1, &a)) != TRIT_OK) {
            printf("Error: %s\n", trit_error_str(err));
            continue;
        }
        if (strlen(arg2) > 0) {
            if ((err = parse_trit_string(arg2, &b)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
                tritbig_free(a);
                continue;
            }
        }

        if (strcmp(op, "add") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_add_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result, &str)) == TRIT_OK) {
                    printf("%s\n", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "sub") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_subtract_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result, &str)) == TRIT_OK) {
                    printf("%s\n", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "mul") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_multiply_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result, &str)) == TRIT_OK) {
                    printf("%s\n", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "div") == 0 && b) {
            TritDivResult result = {{0}, {0}};
            if ((err = tritjs_divide_big(a, b, &result, 3)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* q_str, *r_str;
                if ((err = tritfloat_to_string(result.quotient, &q_str)) == TRIT_OK &&
                    (err = tritfloat_to_string(result.remainder, &r_str)) == TRIT_OK) {
                    printf("%s r %s\n", q_str, r_str);
                    free(q_str);
                    free(r_str);
                }
                tritfloat_free(result.quotient);
                tritfloat_free(result.remainder);
            }
        } else if (strcmp(op, "pow") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_power_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result, &str)) == TRIT_OK) {
                    printf("%s\n", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "fact") == 0) {
            TritBigInt* result;
            if ((err = tritjs_factorial_big(a, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result, &str)) == TRIT_OK) {
                    printf("%s\n", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "sqrt") == 0) {
            TritComplex result;
            if ((err = tritjs_sqrt_complex(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritcomplex_to_string(result, &str)) == TRIT_OK) {
                    printf("%s\n", str);
                    free(str);
                }
                tritcomplex_free(result);
            }
        } else if (strcmp(op, "log3") == 0) {
            TritComplex result;
            if ((err = tritjs_log3_complex(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritcomplex_to_string(result, &str)) == TRIT_OK) {
                    printf("%s\n", str);
                    free(str);
                }
                tritcomplex_free(result);
            }
        } else if (strcmp(op, "sin") == 0) {
            TritComplex result;
            if ((err = tritjs_sin_complex(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritcomplex_to_string(result, &str)) == TRIT_OK) {
                    printf("%s\n", str);
                    free(str);
                }
                tritcomplex_free(result);
            }
        } else if (strcmp(op, "cos") == 0) {
            TritComplex result;
            if ((err = tritjs_cos_complex(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritcomplex_to_string(result, &str)) == TRIT_OK) {
                    printf("%s\n", str);
                    free(str);
                }
                tritcomplex_free(result);
            }
        } else if (strcmp(op, "tan") == 0) {
            TritComplex result;
            if ((err = tritjs_tan_complex(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritcomplex_to_string(result, &str)) == TRIT_OK) {
                    printf("%s\n", str);
                    free(str);
                }
                tritcomplex_free(result);
            }
        } else if (strcmp(op, "pi") == 0) {
            int len;
            Trit* pi;
            if ((err = tritjs_pi(&len, &pi)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str = malloc(len + 1);
                if (str) {
                    for (int i = 0; i < len; i++) str[i] = '0' + pi[i];
                    str[len] = '\0';
                    printf("%s\n", str);
                    free(str);
                }
                free(pi);
            }
        } else {
            printf("Error: Unknown command\n");
        }

        tritbig_free(a);
        if (b) tritbig_free(b);
    }
    if (audit_log) fclose(audit_log);
}

@*2 Main Function.
Entry point for CISA deployment.

@c
int main() {
    run_calculator();
    return 0;
}
