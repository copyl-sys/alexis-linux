@* TritJS: Enhanced Ternary Scientific Calculator with Advanced Features.
This document defines \.{TritJS}, a library for ternary (base-3) arithmetic and scientific operations,
adapted from a JavaScript module into C. It supports basic arithmetic (addition, subtraction, multiplication,
division), scientific functions (exponentiation, square roots, base-3 logarithms, sine, cosine, tangent,
factorials), and constants like π, all operating on trit arrays (digits in $\{0, 1, 2\}$). Key enhancements
include:

- Sign handling for negative numbers, inspired by AI systems, using a sign-magnitude approach.
- Fractional support via `TritFloat` for precise results (e.g., sin(12₃) ≈ 0.221₃).
- Arbitrary-precision arithmetic via `TritBigInt` to handle large numbers.
- Accurate trigonometric scaling using a ternary π constant.
- Native fractional division in `tritjs_divide_big` using `TritFloat`.
- An interactive CLI with add, sub, mul, div, pow, sqrt, log3, sin, cos, tan, fact, and pi.
- Refined error handling with detailed error codes and consistent cleanup.

@c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

@*1 Error Handling.
Expanded error codes for sign-related issues.

@d TritError int
@d TRIT_OK 0
@d TRIT_ERR_MEM 1
@d TRIT_ERR_INPUT 2
@d TRIT_ERR_DIV_ZERO 3
@d TRIT_ERR_OVERFLOW 4
@d TRIT_ERR_UNDEFINED 5
@d TRIT_ERR_NEGATIVE 6
@d TRIT_ERR_PRECISION 7

const char* trit_error_str(TritError err) {
    switch (err) {
        case TRIT_OK: return "No error";
        case TRIT_ERR_MEM: return "Memory allocation failed";
        case TRIT_ERR_INPUT: return "Invalid input (use trits 0-2)";
        case TRIT_ERR_DIV_ZERO: return "Division by zero";
        case TRIT_ERR_OVERFLOW: return "Overflow or value too large";
        case TRIT_ERR_UNDEFINED: return "Operation undefined";
        case TRIT_ERR_NEGATIVE: return "Negative input not supported";
        case TRIT_ERR_PRECISION: return "Precision limit exceeded";
        default: return "Unknown error";
    }
}

@*1 Data Structures and Constants.
Added sign fields to support negative numbers.

@d TRIT_MAX 3
typedef int Trit;
typedef struct {
    int sign;            /* 0 = positive, 1 = negative */
    Trit* digits;        /* Magnitude as trits (0-2) */
    int len;             /* Number of trits */
} TritBigInt;
typedef struct {
    int sign;            /* 0 = positive, 1 = negative */
    Trit* integer;       /* Integer part magnitude */
    Trit* fraction;      /* Fractional part magnitude */
    int i_len;           /* Length of integer part */
    int f_len;           /* Length of fractional part */
} TritFloat;
typedef struct {
    TritFloat quotient;  /* Division result */
    TritFloat remainder; /* Division remainder */
} TritDivResult;

@*1 Helper Functions.
Updated to handle signs.

@<Conversion Functions@>
@<Arithmetic Helpers@>
@<Big Integer Helpers@>
@<Float Helpers@>

@<Conversion Functions@>=
TritError trits_to_binary(Trit* trits, int len, unsigned long* result) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT;
    *result = 0;
    for (int i = 0; i < len; i++) {
        if (trits[i] > 2) return TRIT_ERR_INPUT;
        if (*result > ULONG_MAX >> 2) return TRIT_ERR_OVERFLOW;
        *result = (*result << 2) | trits[i];
    }
    return TRIT_OK;
}

TritError binary_to_trits(unsigned long bin, int len, Trit** trits) {
    if (len <= 0) return TRIT_ERR_INPUT;
    *trits = (Trit*)malloc(len * sizeof(Trit));
    if (!*trits) return TRIT_ERR_MEM;
    for (int i = len - 1; i >= 0; i--) {
        (*trits)[i] = bin & 0x3;
        bin >>= 2;
    }
    return TRIT_OK;
}

@<Arithmetic Helpers@>=
typedef struct { Trit value; int carry; } TritSum;
TritSum trit_add(Trit a, Trit b) {
    int sum = a + b;
    return (TritSum){ sum % TRIT_MAX, sum / TRIT_MAX };
}

typedef struct { Trit value; int borrow; } TritDiff;
TritDiff trit_subtract(Trit a, Trit b) {
    int diff = a - b;
    if (diff >= 0) return (TritDiff){ diff, 0 };
    return (TritDiff){ (diff + TRIT_MAX) % TRIT_MAX, 1 };
}

typedef struct { Trit value; int carry; } TritProd;
TritProd trit_multiply(Trit a, Trit b) {
    int prod = a * b;
    return (TritProd){ prod % TRIT_MAX, prod / TRIT_MAX };
}

@<Big Integer Helpers@>=
TritError tritbig_from_trits(Trit* trits, int len, int sign, TritBigInt** bi) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT;
    *bi = (TritBigInt*)malloc(sizeof(TritBigInt));
    if (!*bi) return TRIT_ERR_MEM;
    (*bi)->digits = (Trit*)malloc(len * sizeof(Trit));
    if (!(*bi)->digits) {
        free(*bi);
        return TRIT_ERR_MEM;
    }
    memcpy((*bi)->digits, trits, len * sizeof(Trit));
    (*bi)->len = len;
    (*bi)->sign = sign; /* Set sign (0 or 1) */
    return TRIT_OK;
}

void tritbig_free(TritBigInt* bi) {
    if (bi) {
        free(bi->digits);
        free(bi);
    }
}

@<Float Helpers@>=
TritError tritfloat_from_bigint(TritBigInt* bi, TritFloat* tf) {
    if (!bi || bi->len <= 0) return TRIT_ERR_INPUT;
    tf->integer = (Trit*)malloc(bi->len * sizeof(Trit));
    if (!tf->integer) return TRIT_ERR_MEM;
    memcpy(tf->integer, bi->digits, bi->len * sizeof(Trit));
    tf->i_len = bi->len;
    tf->fraction = NULL;
    tf->f_len = 0;
    tf->sign = bi->sign; /* Inherit sign */
    return TRIT_OK;
}

void tritfloat_free(TritFloat tf) {
    free(tf.integer);
    if (tf.f_len > 0) free(tf.fraction);
}

@*1 Core Arithmetic Operations.
Updated to handle signs and fractions.

@c
TritError tritjs_add_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    int max_len = (a->len > b->len) ? a->len : b->len;
    Trit* temp = (Trit*)malloc((max_len + 1) * sizeof(Trit));
    if (!temp) return TRIT_ERR_MEM;
    int carry = 0, pos = 0;

    /* Handle sign combinations */
    if (a->sign == b->sign) { /* Same sign: direct addition */
        for (int i = max_len - 1; i >= 0; i--) {
            Trit a_trit = (i < a->len) ? a->digits[i] : 0;
            Trit b_trit = (i < b->len) ? b->digits[i] : 0;
            TritSum sum = trit_add(a_trit + carry, b_trit);
            temp[max_len - pos] = sum.value;
            carry = sum.carry;
            pos++;
        }
        int result_len = carry ? max_len + 1 : max_len;
        if (!carry) memmove(temp, temp + 1, max_len * sizeof(Trit));
        else temp[0] = carry;
        TritError err = tritbig_from_trits(temp, result_len, a->sign, result);
        free(temp);
        return err;
    } else { /* Different signs: subtract larger magnitude */
        TritBigInt* larger = (a->len > b->len || (a->len == b->len && memcmp(a->digits, b->digits, a->len * sizeof(Trit)) >= 0)) ? a : b;
        TritBigInt* smaller = (larger == a) ? b : a;
        int sign = larger->sign;
        for (int i = max_len - 1; i >= 0; i--) {
            Trit l_trit = (i < larger->len) ? larger->digits[i] : 0;
            Trit s_trit = (i < smaller->len) ? smaller->digits[i] : 0;
            TritDiff diff = trit_subtract(l_trit - carry, s_trit);
            temp[max_len - pos] = diff.value;
            carry = diff.borrow;
            pos++;
        }
        int start = 0;
        while (start < max_len - 1 && temp[start] == 0) start++;
        int result_len = max_len - start;
        TritError err = tritbig_from_trits(temp + start, result_len, sign, result);
        free(temp);
        return err;
    }
}

TritError tritjs_subtract_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    /* Flip b's sign and use addition */
    TritBigInt* b_neg = (TritBigInt*)malloc(sizeof(TritBigInt));
    if (!b_neg) return TRIT_ERR_MEM;
    b_neg->digits = (Trit*)malloc(b->len * sizeof(Trit));
    if (!b_neg->digits) {
        free(b_neg);
        return TRIT_ERR_MEM;
    }
    memcpy(b_neg->digits, b->digits, b->len * sizeof(Trit));
    b_neg->len = b->len;
    b_neg->sign = !b->sign; /* Negate b */
    TritError err = tritjs_add_big(a, b_neg, result);
    tritbig_free(b_neg);
    return err;
}

TritError tritjs_multiply_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return TRIT_ERR_INPUT;
    int max_len = a->len + b->len;
    Trit* temp = (Trit*)calloc(max_len, sizeof(Trit));
    if (!temp) return TRIT_ERR_MEM;
    for (int i = a->len - 1; i >= 0; i--) {
        int carry = 0;
        for (int j = b->len - 1; j >= 0; j--) {
            int pos = i + j + 1;
            TritProd prod = trit_multiply(a->digits[i], b->digits[j]);
            TritSum sum = trit_add(temp[pos] + carry, prod.value);
            temp[pos] = sum.value;
            carry = sum.carry + prod.carry;
        }
        if (carry) {
            int carry_pos = i;
            TritSum sum = trit_add(temp[carry_pos] + carry, 0);
            temp[carry_pos] = sum.value;
            if (sum.carry) {
                memmove(temp, temp + 1, max_len * sizeof(Trit));
                temp[0] = sum.carry;
                max_len++;
            }
        }
    }
    int start = 0;
    while (start < max_len - 1 && temp[start] == 0) start++;
    int sign = (a->sign == b->sign) ? 0 : 1; /* Same signs = positive, different = negative */
    TritError err = tritbig_from_trits(temp + start, max_len - start, sign, result);
    free(temp);
    return err;
}

TritError tritjs_divide_big(TritBigInt* a, TritBigInt* b, TritDivResult* result, int precision) {
    if (!a || !b) return TRIT_ERR_INPUT;
    if (precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;

    /* Check if divisor is zero */
    int b_is_zero = 1;
    for (int i = 0; i < b->len; i++) {
        if (b->digits[i] != 0) {
            b_is_zero = 0;
            break;
        }
    }
    if (b_is_zero) return TRIT_ERR_DIV_ZERO;

    /* Convert inputs to TritFloat */
    TritFloat dividend, divisor;
    TritError err;
    if ((err = tritfloat_from_bigint(a, &dividend)) != TRIT_OK) return err;
    if ((err = tritfloat_from_bigint(b, &divisor)) != TRIT_OK) {
        tritfloat_free(dividend);
        return err;
    }

    /* Allocate quotient and remainder */
    result->quotient.integer = (Trit*)malloc(a->len * sizeof(Trit));
    if (!result->quotient.integer) {
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return TRIT_ERR_MEM;
    }
    result->quotient.fraction = (Trit*)malloc(precision * sizeof(Trit));
    if (!result->quotient.fraction) {
        free(result->quotient.integer);
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return TRIT_ERR_MEM;
    }
    result->remainder.integer = (Trit*)malloc(b->len * sizeof(Trit));
    if (!result->remainder.integer) {
        free(result->quotient.integer);
        free(result->quotient.fraction);
        tritfloat_free(dividend);
        tritfloat_free(divisor);
        return TRIT_ERR_MEM;
    }
    result->remainder.fraction = NULL;
    result->quotient.i_len = a->len;
    result->quotient.f_len = precision;
    result->remainder.i_len = b->len;
    result->remainder.f_len = 0;
    result->quotient.sign = (a->sign == b->sign) ? 0 : 1; /* Sign rule */
    result->remainder.sign = a->sign; /* Remainder keeps dividend's sign */

    /* Initialize quotient and remainder */
    memset(result->quotient.integer, 0, a->len * sizeof(Trit));
    memset(result->quotient.fraction, 0, precision * sizeof(Trit));
    memcpy(result->remainder.integer, a->digits, a->len * sizeof(Trit));

    /* Integer division */
    for (int i = 0; i < a->len; i++) {
        int digit = 0;
        TritBigInt* temp_rem;
        if ((err = tritbig_from_trits(result->remainder.integer, result->remainder.i_len, result->remainder.sign, &temp_rem)) != TRIT_OK) {
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return err;
        }
        while (1) {
            TritBigInt* temp_sub;
            if ((err = tritjs_subtract_big(temp_rem, b, &temp_sub)) != TRIT_OK) {
                if (err == TRIT_ERR_NEGATIVE) break;
                tritbig_free(temp_rem);
                tritfloat_free(result->quotient);
                tritfloat_free(result->remainder);
                tritfloat_free(dividend);
                tritfloat_free(divisor);
                return err;
            }
            tritbig_free(temp_rem);
            temp_rem = temp_sub;
            digit++;
        }
        result->quotient.integer[i] = digit;
        memcpy(result->remainder.integer, temp_rem->digits, temp_rem->len * sizeof(Trit));
        result->remainder.i_len = temp_rem->len;
        tritbig_free(temp_rem);
    }

    /* Fractional division */
    for (int i = 0; i < precision; i++) {
        TritBigInt* temp_rem;
        if ((err = tritbig_from_trits(result->remainder.integer, result->remainder.i_len, result->remainder.sign, &temp_rem)) != TRIT_OK) {
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return err;
        }
        TritBigInt* three;
        if ((err = tritbig_from_trits((Trit[]){1}, 1, 0, &three)) != TRIT_OK) {
            tritbig_free(temp_rem);
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return err;
        }
        TritBigInt* temp_mul;
        if ((err = tritjs_multiply_big(temp_rem, three, &temp_mul)) != TRIT_OK) {
            tritbig_free(temp_rem);
            tritbig_free(three);
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return err;
        }
        tritbig_free(temp_rem);
        tritbig_free(three);
        temp_rem = temp_mul;

        int digit = 0;
        while (1) {
            TritBigInt* temp_sub;
            if ((err = tritjs_subtract_big(temp_rem, b, &temp_sub)) != TRIT_OK) {
                if (err == TRIT_ERR_NEGATIVE) break;
                tritbig_free(temp_rem);
                tritfloat_free(result->quotient);
                tritfloat_free(result->remainder);
                tritfloat_free(dividend);
                tritfloat_free(divisor);
                return err;
            }
            tritbig_free(temp_rem);
            temp_rem = temp_sub;
            digit++;
        }
        result->quotient.fraction[i] = digit;
        memcpy(result->remainder.integer, temp_rem->digits, temp_rem->len * sizeof(Trit));
        result->remainder.i_len = temp_rem->len;
        tritbig_free(temp_rem);
    }

    /* Trim leading zeros in quotient */
    int int_start = 0;
    while (int_start < result->quotient.i_len - 1 && result->quotient.integer[int_start] == 0) int_start++;
    if (int_start > 0) {
        Trit* new_int = (Trit*)malloc((result->quotient.i_len - int_start) * sizeof(Trit));
        if (!new_int) {
            tritfloat_free(result->quotient);
            tritfloat_free(result->remainder);
            tritfloat_free(dividend);
            tritfloat_free(divisor);
            return TRIT_ERR_MEM;
        }
        memcpy(new_int, result->quotient.integer + int_start, (result->quotient.i_len - int_start) * sizeof(Trit));
        free(result->quotient.integer);
        result->quotient.integer = new_int;
        result->quotient.i_len -= int_start;
    }

    tritfloat_free(dividend);
    tritfloat_free(divisor);
    return TRIT_OK;
}

@*1 Scientific Operations.
Updated to handle signs.

@c
TritError tritjs_power_big(TritBigInt* base, TritBigInt* exp, TritBigInt** result) {
    if (!base || !exp) return TRIT_ERR_INPUT;
    TritError err;
    if ((err = tritbig_from_trits((Trit[]){1}, 1, 0, result)) != TRIT_OK) return err;
    unsigned long exp_bin;
    if ((err = trits_to_binary(exp->digits, exp->len, &exp_bin)) != TRIT_OK) {
        tritbig_free(*result);
        return err;
    }
    if (exp_bin > 1000) {
        tritbig_free(*result);
        return TRIT_ERR_OVERFLOW;
    }
    int sign = (base->sign && (exp_bin % 2 == 1)) ? 1 : 0; /* Negative base, odd exp = negative */
    for (unsigned long i = 0; i < exp_bin; i++) {
        TritBigInt* temp;
        if ((err = tritjs_multiply_big(*result, base, &temp)) != TRIT_OK) {
            tritbig_free(*result);
            return err;
        }
        tritbig_free(*result);
        *result = temp;
    }
    (*result)->sign = sign;
    return TRIT_OK;
}

TritError tritjs_sqrt_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    if (a->sign) return TRIT_ERR_NEGATIVE; /* No complex numbers yet */
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    if (a_bin == 0) {
        result->integer = (Trit*)malloc(1 * sizeof(Trit));
        if (!result->integer) return TRIT_ERR_MEM;
        result->integer[0] = 0;
        result->i_len = 1;
        result->fraction = (Trit*)malloc(precision * sizeof(Trit));
        if (!result->fraction) {
            free(result->integer);
            return TRIT_ERR_MEM;
        }
        memset(result->fraction, 0, precision * sizeof(Trit));
        result->f_len = precision;
        result->sign = 0;
        return TRIT_OK;
    }
    double sqrt_val = sqrt((double)a_bin);
    unsigned long int_part = (unsigned long)sqrt_val;
    double frac_part = sqrt_val - int_part;
    if ((err = binary_to_trits(int_part, (a->len + 1) / 2, &result->integer)) != TRIT_OK) return err;
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        return err;
    }
    result->i_len = (a->len + 1) / 2;
    result->f_len = precision;
    result->sign = 0; /* Sqrt is always non-negative */
    return TRIT_OK;
}

TritError tritjs_log3_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    if (a->sign) return TRIT_ERR_NEGATIVE; /* Log of negative undefined */
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    if (a_bin <= 0) return TRIT_ERR_UNDEFINED;
    double log_val = log((double)a_bin) / log(3.0);
    unsigned long int_part = (unsigned long)log_val;
    double frac_part = log_val - int_part;
    if ((err = binary_to_trits(int_part, a->len, &result->integer)) != TRIT_OK) return err;
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        return err;
    }
    result->i_len = a->len;
    result->f_len = precision;
    result->sign = 0; /* Log is positive for positive input */
    return TRIT_OK;
}

TritError tritjs_sin_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    int pi_len;
    Trit* pi;
    if ((err = tritjs_pi(&pi_len, &pi)) != TRIT_OK) return err;
    unsigned long pi_bin;
    if ((err = trits_to_binary(pi, pi_len, &pi_bin)) != TRIT_OK) {
        free(pi);
        return err;
    }
    double a_rad = (double)a_bin * M_PI / (double)pi_bin * (a->sign ? -1 : 1); /* Apply sign */
    double sin_val = sin(a_rad);
    int sign = (sin_val < 0) ? 1 : 0;
    double abs_val = fabs(sin_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;
    if ((err = binary_to_trits(int_part, 1, &result->integer)) != TRIT_OK) {
        free(pi);
        return err;
    }
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        free(pi);
        return err;
    }
    result->i_len = 1;
    result->f_len = precision;
    result->sign = sign;
    free(pi);
    return TRIT_OK;
}

TritError tritjs_cos_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    int pi_len;
    Trit* pi;
    if ((err = tritjs_pi(&pi_len, &pi)) != TRIT_OK) return err;
    unsigned long pi_bin;
    if ((err = trits_to_binary(pi, pi_len, &pi_bin)) != TRIT_OK) {
        free(pi);
        return err;
    }
    double a_rad = (double)a_bin * M_PI / (double)pi_bin * (a->sign ? -1 : 1);
    double cos_val = cos(a_rad);
    int sign = (cos_val < 0) ? 1 : 0;
    double abs_val = fabs(cos_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;
    if ((err = binary_to_trits(int_part, 1, &result->integer)) != TRIT_OK) {
        free(pi);
        return err;
    }
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        free(pi);
        return err;
    }
    result->i_len = 1;
    result->f_len = precision;
    result->sign = sign;
    free(pi);
    return TRIT_OK;
}

TritError tritjs_tan_float(TritBigInt* a, int precision, TritFloat* result) {
    if (!a || precision <= 0 || precision > 10) return TRIT_ERR_PRECISION;
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    int pi_len;
    Trit* pi;
    if ((err = tritjs_pi(&pi_len, &pi)) != TRIT_OK) return err;
    unsigned long pi_bin;
    if ((err = trits_to_binary(pi, pi_len, &pi_bin)) != TRIT_OK) {
        free(pi);
        return err;
    }
    double a_rad = (double)a_bin * M_PI / (double)pi_bin * (a->sign ? -1 : 1);
    double tan_val = tan(a_rad);
    if (fabs(tan_val) > 1000.0) {
        free(pi);
        return TRIT_ERR_UNDEFINED;
    }
    int sign = (tan_val < 0) ? 1 : 0;
    double abs_val = fabs(tan_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;
    if ((err = binary_to_trits(int_part, (int)log(abs_val)/log(3) + 1, &result->integer)) != TRIT_OK) {
        free(pi);
        return err;
    }
    if ((err = binary_to_trits((unsigned long)(frac_part * pow(3, precision)), precision, &result->fraction)) != TRIT_OK) {
        free(result->integer);
        free(pi);
        return err;
    }
    result->i_len = (int)log(abs_val)/log(3) + 1;
    result->f_len = precision;
    result->sign = sign;
    free(pi);
    return TRIT_OK;
}

TritError tritjs_factorial_big(TritBigInt* a, TritBigInt** result) {
    if (!a) return TRIT_ERR_INPUT;
    if (a->sign) return TRIT_ERR_NEGATIVE; /* Factorial of negative undefined */
    unsigned long a_bin;
    TritError err;
    if ((err = trits_to_binary(a->digits, a->len, &a_bin)) != TRIT_OK) return err;
    if (a_bin > 20) return TRIT_ERR_OVERFLOW;
    if ((err = tritbig_from_trits((Trit[]){1}, 1, 0, result)) != TRIT_OK) return err;
    for (unsigned long i = 1; i <= a_bin; i++) {
        Trit* i_trits;
        if ((err = binary_to_trits(i, 2, &i_trits)) != TRIT_OK) {
            tritbig_free(*result);
            return err;
        }
        TritBigInt* i_bi;
        if ((err = tritbig_from_trits(i_trits, 2, 0, &i_bi)) != TRIT_OK) {
            free(i_trits);
            tritbig_free(*result);
            return err;
        }
        free(i_trits);
        TritBigInt* temp;
        if ((err = tritjs_multiply_big(*result, i_bi, &temp)) != TRIT_OK) {
            tritbig_free(i_bi);
            tritbig_free(*result);
            return err;
        }
        tritbig_free(*result);
        tritbig_free(i_bi);
        *result = temp;
    }
    return TRIT_OK;
}

TritError tritjs_pi(int* len, Trit** pi) {
    Trit pi_val[] = {1, 0, 0, 1, 0, 2, 2, 1};
    *len = 8;
    *pi = (Trit*)malloc(*len * sizeof(Trit));
    if (!*pi) return TRIT_ERR_MEM;
    memcpy(*pi, pi_val, *len * sizeof(Trit));
    return TRIT_OK;
}

@*1 Utility Functions.
Updated for sign handling.

@c
TritError tritjs_to_string(Trit* trits, int len, char** str) {
    if (!trits || len <= 0) return TRIT_ERR_INPUT;
    *str = (char*)malloc(len + 1);
    if (!*str) return TRIT_ERR_MEM;
    for (int i = 0; i < len; i++) (*str)[i] = '0' + trits[i];
    (*str)[len] = '\0';
    return TRIT_OK;
}

TritError tritfloat_to_string(TritFloat tf, char** str) {
    if (!tf.integer || tf.i_len <= 0) return TRIT_ERR_INPUT;
    char* mag_str;
    TritError err;
    if ((err = tritjs_to_string(tf.integer, tf.i_len, &mag_str)) != TRIT_OK) return err;
    if (tf.f_len > 0) {
        char* frac_str;
        if ((err = tritjs_to_string(tf.fraction, tf.f_len, &frac_str)) != TRIT_OK) {
            free(mag_str);
            return err;
        }
        *str = (char*)malloc(tf.i_len + tf.f_len + 2 + (tf.sign ? 1 : 0));
        if (!*str) {
            free(mag_str);
            free(frac_str);
            return TRIT_ERR_MEM;
        }
        sprintf(*str, "%s%s.%s", tf.sign ? "-" : "", mag_str, frac_str);
        free(mag_str);
        free(frac_str);
    } else {
        *str = (char*)malloc(tf.i_len + 1 + (tf.sign ? 1 : 0));
        if (!*str) {
            free(mag_str);
            return TRIT_ERR_MEM;
        }
        sprintf(*str, "%s%s", tf.sign ? "-" : "", mag_str);
        free(mag_str);
    }
    return TRIT_OK;
}

@*1 CLI Functions.
Updated CLI with sign support and new operations.

@c
TritError parse_trit_string(const char* str, TritBigInt** bi) {
    if (!str || strlen(str) == 0) return TRIT_ERR_INPUT;
    int sign = (str[0] == '-') ? 1 : 0;
    const char* mag_str = (str[0] == '-') ? str + 1 : str;
    int len = strlen(mag_str);
    Trit* trits = (Trit*)malloc(len * sizeof(Trit));
    if (!trits) return TRIT_ERR_MEM;
    for (int i = 0; i < len; i++) {
        if (mag_str[i] < '0' || mag_str[i] > '2') {
            free(trits);
            return TRIT_ERR_INPUT;
        }
        trits[i] = mag_str[i] - '0';
    }
    TritError err = tritbig_from_trits(trits, len, sign, bi);
    free(trits);
    return err;
}

void run_calculator() {
    char input[256];
    printf("TritJS Ternary Calculator (enter 'quit' to exit)\n");
    printf("Commands: add/sub/mul/div/pow/sqrt/log3/sin/cos/tan/fact/pi <arg1> [arg2]\n");
    while (1) {
        printf("> ");
        if (!fgets(input, 256, stdin)) break;
        input[strcspn(input, "\n")] = 0;
        if (strcmp(input, "quit") == 0) break;

        char op[10], arg1[20], arg2[20] = "";
        int parsed = sscanf(input, "%9s %19s %19s", op, arg1, arg2);
        if (parsed < 2) {
            printf("Error: Invalid command format (e.g., 'add 12 2')\n");
            continue;
        }

        TritBigInt* a = NULL;
        TritBigInt* b = NULL;
        TritError err;

        if ((err = parse_trit_string(arg1, &a)) != TRIT_OK) {
            printf("Error with arg1: %s\n", trit_error_str(err));
            continue;
        }
        if (strlen(arg2) > 0) {
            if ((err = parse_trit_string(arg2, &b)) != TRIT_OK) {
                printf("Error with arg2: %s\n", trit_error_str(err));
                tritbig_free(a);
                continue;
            }
        }

        if (strcmp(op, "add") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_add_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s%s\n", result->sign ? "-" : "", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "sub") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_subtract_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s%s\n", result->sign ? "-" : "", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "mul") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_multiply_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s%s\n", result->sign ? "-" : "", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "div") == 0 && b) {
            TritDivResult result;
            if ((err = tritjs_divide_big(a, b, &result, 3)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* q_str;
                char* r_str;
                if ((err = tritfloat_to_string(result.quotient, &q_str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else if ((err = tritfloat_to_string(result.remainder, &r_str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                    free(q_str);
                } else {
                    printf("%s r %s\n", q_str, r_str);
                    free(q_str);
                    free(r_str);
                }
                tritfloat_free(result.quotient);
                tritfloat_free(result.remainder);
            }
        } else if (strcmp(op, "pow") == 0 && b) {
            TritBigInt* result;
            if ((err = tritjs_power_big(a, b, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s%s\n", result->sign ? "-" : "", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "sqrt") == 0) {
            TritFloat result;
            if ((err = tritjs_sqrt_float(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritfloat_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritfloat_free(result);
            }
        } else if (strcmp(op, "log3") == 0) {
            TritFloat result;
            if ((err = tritjs_log3_float(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritfloat_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritfloat_free(result);
            }
        } else if (strcmp(op, "sin") == 0) {
            TritFloat result;
            if ((err = tritjs_sin_float(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritfloat_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritfloat_free(result);
            }
        } else if (strcmp(op, "cos") == 0) {
            TritFloat result;
            if ((err = tritjs_cos_float(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritfloat_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritfloat_free(result);
            }
        } else if (strcmp(op, "tan") == 0) {
            TritFloat result;
            if ((err = tritjs_tan_float(a, 3, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritfloat_to_string(result, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                tritfloat_free(result);
            }
        } else if (strcmp(op, "fact") == 0) {
            TritBigInt* result;
            if ((err = tritjs_factorial_big(a, &result)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(result->digits, result->len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s%s\n", result->sign ? "-" : "", str);
                    free(str);
                }
                tritbig_free(result);
            }
        } else if (strcmp(op, "pi") == 0) {
            int len;
            Trit* pi;
            if ((err = tritjs_pi(&len, &pi)) != TRIT_OK) {
                printf("Error: %s\n", trit_error_str(err));
            } else {
                char* str;
                if ((err = tritjs_to_string(pi, len, &str)) != TRIT_OK) {
                    printf("Error: %s\n", trit_error_str(err));
                } else {
                    printf("%s\n", str);
                    free(str);
                }
                free(pi);
            }
        } else {
            printf("Error: Unknown command or missing argument\n");
        }

        tritbig_free(a);
        if (b) tritbig_free(b);
    }
}

@*1 Main Function.
Launches the calculator.

@c
int main() {
    run_calculator();
    return 0;
}
