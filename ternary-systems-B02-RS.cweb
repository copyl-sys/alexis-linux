/*=====================================================================
 Ternary Systems B02-RS: Cross-Platform Unified Ternary System in Rust
 Version: B02-RS (Portable, Fully Rust-Based)
 Author: Copyleft Systems
 Date: Mar 3 2025 (refactored for Rust)

 This literate program reimplements the ternary computing system entirely in Rust,
 replacing the previous C-based kernel module and Java utility with a single,
 cohesive Rust application. The core functionality includes:
 - Ternary arithmetic expression parsing,
 - Tower of Hanoi solver,
 - Matrix operations (creation, addition, multiplication, serialization, deserialization),
 - Discrete math-enhanced opcode encoding and validation.
 By leveraging Rust's safety guarantees, ownership model, and modern features,
 this version ensures memory safety, eliminates manual memory management,
 and provides a robust command-line utility. The system is fully portable across
 Windows, macOS, Linux, BSD, and other platforms supported by Rust, with no
 kernel-specific componentsâ€”everything runs in user space. The Rust implementation
 uses idiomatic constructs like enums, pattern matching, and the standard library
 for file I/O and parsing, enhancing reliability and maintainability.
=====================================================================*/

/*=====================================================================
 Rust Main Module: main.rs
 This file serves as the entry point and core implementation of the ternary system
 in Rust. It defines all necessary structs, functions, and the command-line interface.
 The program supports both interactive mode and command-line arguments, mirroring
 the functionality of previous versions while improving safety and expressiveness.
=====================================================================*/
@* Rust Main Module: main.rs
@o main.rs
@c
use std::fs::File;
use std::io::{self, BufRead, BufReader, Write};
use std::env;
use std::process;

// Enum to represent ternary parse errors
#[derive(Debug)]
enum ParseError {
 InvalidDigit(char),
 UnexpectedChar(char),
 MissingClosingParen,
 DivisionByZero,
 EmptyExpression,
}

impl std::fmt::Display for ParseError {
 fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
 match self {
 ParseError::InvalidDigit(c) => write!(f, "Invalid digit '{}': expected 0, 1, or 2", c),
 ParseError::UnexpectedChar(c) => write!(f, "Unexpected character '{}'", c),
 ParseError::MissingClosingParen => write!(f, "Missing closing parenthesis"),
 ParseError::DivisionByZero => write!(f, "Division by zero"),
 ParseError::EmptyExpression => write!(f, "Expression is empty"),
 }
 }
}

// Struct for matrix operations
#[derive(Debug)]
struct TMatrix {
 rows: usize,
 cols: usize,
 data: Vec<Vec<i32>>,
}

impl TMatrix {
 // Create a new matrix with given dimensions, initialized to zeros
 fn new(rows: usize, cols: usize) -> TMatrix {
 let data = vec![vec![0; cols]; rows];
 TMatrix { rows, cols, data }
 }

 // Add two matrices
 fn add(&self, other: &TMatrix) -> Result<TMatrix, String> {
 if self.rows != other.rows || self.cols != other.cols {
 return Err("Matrix dimensions mismatch for addition".to_string());
 }
 let mut result = TMatrix::new(self.rows, self.cols);
 for i in 0..self.rows {
 for j in 0..self.cols {
 result.data[i][j] = self.data[i][j] + other.data[i][j];
 }
 }
 Ok(result)
 }

 // Multiply two matrices
 fn multiply(&self, other: &TMatrix) -> Result<TMatrix, String> {
 if self.cols != other.rows {
 return Err("Matrix dimensions mismatch for multiplication".to_string());
 }
 let mut result = TMatrix::new(self.rows, other.cols);
 for i in 0..self.rows {
 for j in 0..other.cols {
 let mut sum = 0;
 for k in 0..self.cols {
 sum += self.data[i][k] * other.data[k][j];
 }
 result.data[i][j] = sum;
 }
 }
 Ok(result)
 }

 // Serialize matrix to a file in ternary format
 fn serialize(&self, filename: &str) -> io::Result<()> {
 let mut file = File::create(filename)?;
 writeln!(file, "{} {}", self.rows, self.cols)?;
 for i in 0..self.rows {
 for j in 0..self.cols {
 let ternary = int_to_ternary(self.data[i][j]);
 write!(file, "{} ", ternary)?;
 }
 writeln!(file)?;
 }
 Ok(())
 }

 // Deserialize matrix from a file
 fn deserialize(filename: &str) -> io::Result<TMatrix> {
 let file = File::open(filename)?;
 let reader = BufReader::new(file);
 let mut lines = reader.lines();
 
 // Read dimensions
 let first_line = lines.next().ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, "Empty file"))??;
 let dims: Vec<usize> = first_line.split_whitespace()
 .map(|s| s.parse().map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e)))
 .collect::<Result<_, _>>()?;
 if dims.len() != 2 {
 return Err(io::Error::new(io::ErrorKind::InvalidData, "Invalid dimensions"));
 }
 let rows = dims[0];
 let cols = dims[1];
 
 // Read matrix data
 let mut data = Vec::with_capacity(rows);
 for line in lines.take(rows) {
 let line = line?;
 let row: Vec<i32> = line.split_whitespace()
 .map(|s| parse_ternary(s).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e.to_string())))
 .collect::<Result<_, _>>()?;
 if row.len() != cols {
 return Err(io::Error::new(io::ErrorKind::InvalidData, "Row length mismatch"));
 }
 data.push(row);
 }
 if data.len() != rows {
 return Err(io::Error::new(io::ErrorKind::InvalidData, "Insufficient rows"));
 }
 
 Ok(TMatrix { rows, cols, data })
 }
}

// Ternary arithmetic expression parser
fn tritjs_eval_expression(expr: &str) -> Result<i32, ParseError> {
 let expr = expr.trim();
 if expr.is_empty() {
 return Err(ParseError::EmptyExpression);
 }
 let chars: Vec<char> = expr.chars().collect();
 let mut pos = 0;
 let result = parse_expr(&chars, &mut pos)?;
 // Check for trailing characters
 while pos < chars.len() {
 if !chars[pos].is_whitespace() {
 return Err(ParseError::UnexpectedChar(chars[pos]));
 }
 pos += 1;
 }
 Ok(result)
}

fn parse_expr(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
 let mut value = parse_term(chars, pos)?;
 while *pos < chars.len() {
 skip_whitespace(chars, pos);
 match chars.get(*pos) {
 Some('+') => {
 *pos += 1;
 value += parse_term(chars, pos)?;
 }
 Some('-') => {
 *pos += 1;
 value -= parse_term(chars, pos)?;
 }
 _ => break,
 }
 }
 Ok(value)
}

fn parse_term(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
 let mut value = parse_factor(chars, pos)?;
 while *pos < chars.len() {
 skip_whitespace(chars, pos);
 match chars.get(*pos) {
 Some('*') => {
 *pos += 1;
 value *= parse_factor(chars, pos)?;
 }
 Some('/') => {
 *pos += 1;
 let next = parse_factor(chars, pos)?;
 if next == 0 {
 return Err(ParseError::DivisionByZero);
 }
 value /= next;
 }
 _ => break,
 }
 }
 Ok(value)
}

fn parse_factor(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
 skip_whitespace(chars, pos);
 if *pos >= chars.len() {
 return Err(ParseError::UnexpectedChar('\0'));
 }
 if chars[*pos] == '(' {
 *pos += 1;
 let value = parse_expr(chars, pos)?;
 skip_whitespace(chars, pos);
 if *pos >= chars.len() || chars[*pos] != ')' {
 return Err(ParseError::MissingClosingParen);
 }
 *pos += 1;
 Ok(value)
 } else {
 parse_number(chars, pos)
 }
}

fn parse_number(chars: &[char], pos: &mut usize) -> Result<i32, ParseError> {
 skip_whitespace(chars, pos);
 if *pos >= chars.len() {
 return Err(ParseError::UnexpectedChar('\0'));
 }
 let mut value = 0;
 let mut has_digits = false;
 while *pos < chars.len() {
 let c = chars[*pos];
 if c >= '0' && c <= '2' {
 value = value * 3 + (c as i32 - '0' as i32);
 has_digits = true;
 *pos += 1;
 } else {
 break;
 }
 }
 if !has_digits {
 return Err(ParseError::InvalidDigit(chars[*pos]));
 }
 Ok(value)
}

fn skip_whitespace(chars: &[char], pos: &mut usize) {
 while *pos < chars.len() && chars[*pos].is_whitespace() {
 *pos += 1;
 }
}

// Convert an integer to ternary string
fn int_to_ternary(n: i32) -> String {
 if n == 0 {
 return "0".to_string();
 }
 let mut digits = Vec::new();
 let mut num = n.abs();
 while num > 0 {
 digits.push((num % 3) as u8 + b'0');
 num /= 3;
 }
 if n < 0 {
 digits.push(b'-');
 }
 String::from_utf8(digits.into_iter().rev().collect()).unwrap()
}

// Parse a ternary string back to an integer
fn parse_ternary(s: &str) -> Result<i32, ParseError> {
 let mut value = 0;
 let mut is_negative = false;
 let chars: Vec<char> = s.chars().collect();
 let mut i = 0;
 
 if chars.is_empty() {
 return Err(ParseError::EmptyExpression);
 }
 if chars[0] == '-' {
 is_negative = true;
 i += 1;
 }
 
 while i < chars.len() {
 let c = chars[i];
 if c < '0' || c > '2' {
 return Err(ParseError::InvalidDigit(c));
 }
 value = value * 3 + (c as i32 - '0' as i32);
 i += 1;
 }
 Ok(if is_negative { -value } else { value })
}

// Tower of Hanoi solver
fn solve_hanoi(n: i32) {
 let mut state: Vec<i32> = vec![0; n as usize];
 println!("Initial state (all disks on peg 0):");
 print_state(&state);
 solve_hanoi_recursive(n, 0, 2, 1, &mut state);
}

fn solve_hanoi_recursive(n: i32, from: i32, to: i32, aux: i32, state: &mut Vec<i32>) {
 if n == 0 {
 return;
 }
 solve_hanoi_recursive(n - 1, from, aux, to, state);
 hanoi_move(n - 1, from, to, state);
 solve_hanoi_recursive(n - 1, aux, to, from, state);
}

fn hanoi_move(disk: i32, from: i32, to: i32, state: &mut Vec<i32>) {
 println!("Move disk {} from peg {} to peg {}", disk, from, to);
 state[disk as usize] = to;
 print_state(state);
}

fn print_state(state: &[i32]) {
 print!("State: ");
 for &peg in state.iter().rev() {
 print!("{}", peg);
 }
 println!();
}

// Discrete math-enhanced opcode functions
fn discrete_opcode_encode(opcode: i32) -> String {
 let ternary = int_to_ternary(opcode);
 let checksum = ternary.chars()
 .filter(|&c| c >= '0' && c <= '2')
 .map(|c| (c as u32 - '0' as u32) as i32)
 .sum::<i32>() % 3;
 format!("{}{}", ternary, checksum)
}

fn discrete_opcode_validate(encoded: &str) -> bool {
 if encoded.len() < 2 {
 return false;
 }
 let (code, checksum) = encoded.split_at(encoded.len() - 1);
 let checksum_digit = checksum.chars().next().unwrap();
 if checksum_digit < '0' || checksum_digit > '2' {
 return false;
 }
 let computed_sum = code.chars()
 .filter(|&c| c >= '0' && c <= '2')
 .map(|c| (c as u32 - '0' as u32) as i32)
 .sum::<i32>() % 3;
 computed_sum == (checksum_digit as u32 - '0' as u32) as i32
}

// Command-line interface
fn print_help() {
 println!("Ternary Systems B02-RS Utility (Rust Version)");
 println!("=================================================");
 println!("Usage:");
 println!(" ternary_system -expr \"expression\"");
 println!(" ternary_system -hanoi n");
 println!(" ternary_system -opcode number");
 println!(" ternary_system interactive");
 println!("=================================================");
}

fn interactive_mode() {
 let stdin = io::stdin();
 println!("Entering interactive mode. Type 'help' for commands, 'exit' to quit.");
 loop {
 print!("ts> ");
 io::stdout().flush().unwrap();
 let mut line = String::new();
 stdin.read_line(&mut line).unwrap();
 let line = line.trim();
 if line.is_empty() {
 continue;
 }
 let tokens: Vec<&str> = line.splitn(2, ' ').collect();
 match tokens[0] {
 "exit" => {
 println!("Exiting interactive mode.");
 break;
 }
 "help" => print_help(),
 "expr" => {
 if tokens.len() > 1 {
 match tritjs_eval_expression(tokens[1]) {
 Ok(result) => println!("Expression evaluated to (ternary): {}", int_to_ternary(result)),
 Err(e) => println!("Error: {}", e),
 }
 } else {
 println!("Usage: expr <expression>");
 }
 }
 "hanoi" => {
 if tokens.len() > 1 {
 if let Ok(n) = tokens[1].parse::<i32>() {
 if n >= 0 {
 solve_hanoi(n);
 } else {
 println!("Number of disks must be non-negative");
 }
 } else {
 println!("Invalid number for hanoi");
 }
 } else {
 println!("Usage: hanoi <number>");
 }
 }
 "opcode" => {
 if tokens.len() > 1 {
 if let Ok(opcode) = tokens[1].parse::<i32>() {
 let encoded = discrete_opcode_encode(opcode);
 println!("Opcode {} encoded as: {}", opcode, encoded);
 println!("Encoded opcode is {}", if discrete_opcode_validate(&encoded) { "valid" } else { "invalid" });
 } else {
 println!("Invalid opcode");
 }
 } else {
 println!("Usage: opcode <number>");
 }
 }
 _ => println!("Unknown command. Type 'help' for available commands."),
 }
 }
}

fn main() {
 let args: Vec<String> = env::args().collect();
 if args.len() < 2 || args[1] == "interactive" {
 interactive_mode();
 } else if args[1] == "-expr" && args.len() > 2 {
 match tritjs_eval_expression(&args[2]) {
 Ok(result) => println!("Expression evaluated to (ternary): {}", int_to_ternary(result)),
 Err(e) => {
 println!("Error: {}", e);
 process::exit(1);
 }
 }
 } else if args[1] == "-hanoi" && args.len() > 2 {
 match args[2].parse::<i32>() {
 Ok(n) if n >= 0 => solve_hanoi(n),
 Ok(_) => {
 println!("Number of disks must be non-negative");
 process::exit(1);
 }
 Err(_) => {
 println!("Invalid number for hanoi");
 process::exit(1);
 }
 }
 } else if args[1] == "-opcode" && args.len() > 2 {
 match args[2].parse::<i32>() {
 Ok(opcode) => {
 let encoded = discrete_opcode_encode(opcode);
 println!("Opcode {} encoded as: {}", opcode, encoded);
 println!("Encoded opcode is {}", if discrete_opcode_validate(&encoded) { "valid" } else { "invalid" });
 }
 Err(_) => {
 println!("Invalid opcode");
 process::exit(1);
 }
 }
 } else {
 print_help();
 process::exit(1);
 }
}
@*/

/*=====================================================================
 End of Ternary Systems B02-RS CWEB Document
=====================================================================*/
