@* TritJS-CISA: A Ternary Calculator with POSIX Enhancements.
This document defines \.{TritJS-CISA}, a ternary (base-3) scientific calculator built for
cybersecurity and educational use. In this revision, we leverage common POSIX commands and
functions to minimize the custom code base. Standard functions from <unistd.h>, <stdlib.h>,
<fcntl.h>, and others are used instead of reinventing the wheel.

Enhancements include:
- **POSIX Command Wrappers:** Use system() and standard POSIX functions (mkstemp, strdup, stat)
  to handle file and memory operations.
- **Robust Error Handling and Logging:** Detailed error messages and audit logging with timestamps.
- **Modular and Minimal Code:** Clear organization into sections, reducing complexity.
- **Binary/Trinary Conversions:** New functions convert native binary integers to the internal
  trinary representation (TritBigInt) and vice versa.
- **Enhanced CLI:** Supports common arithmetic and scientific commands plus new commands:
    • bin2tri <number> – converts a binary integer to trinary.
    • tri2bin <trit> – converts a trinary number (string of 0, 1, 2) to binary.
- **Optional GNU Readline Integration:** For improved interactive command-line features.
- **Simple Test Suite and Profiling:** A “test” command runs unit tests; profiling macros measure
  performance of test routines.

This version, dated March 01, 2025, builds on previous revisions to produce a lean, POSIX-based
codebase with enhanced functionality.

@*1 Usage and Documentation.
Compile and run:
- \.{cweave tritjs_cisa_revised_posix.cweb} → \.{tritjs_cisa_revised_posix.tex}.
- \.{ctangle tritjs_cisa_revised_posix.cweb} → \.{tritjs_cisa_revised_posix.c}.
- \.{gcc -DUSE_READLINE -o tritjs_cisa tritjs_cisa_revised_posix.c -lm -lreadline}
  (or omit -DUSE_READLINE to use fgets).
- \.{./tritjs_cisa}  
  Type “help” for a list of commands; “test” to run the automated test suite.

Supported commands include:
- Arithmetic: \.{add}, \.{sub}, \.{mul}, \.{div}, \.{pow}, \.{fact}
- Scientific: \.{sqrt}, \.{log3}, \.{sin}, \.{cos}, \.{tan}, \.{pi}
- Stats: \.{stats [quick|merge]} (mean, mode, median; auto-selects if omitted)
- Scripting: \.{PROG <name> {<cmds>}}, \.{RUN <name>}
- Storage: \.{save <file>}, \.{load <file>} (MIME type \.{application/x-tritjs-cisa})
- Conversion: \.{bin2tri <number>}, \.{tri2bin <trit>}
- General: \.{help}, \.{quit}, \.{recall <n>}, \.{<var>=<value>}, \.{clear}, \.{test}

Inputs are in base‑3 (digits 0, 1, 2). State is saved in \.{.trit} files.

@*1 Implementation.
@c
/* --- Standard Includes --- */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>
#include <limits.h>     /* For ULONG_MAX */

#ifdef USE_READLINE
#include <readline/readline.h>
#include <readline/history.h>
#endif

#define TRIT_MAX 3
#define MAX_MMAP_SIZE (1024 * 1024)
#define MAX_DISPLAY_WIDTH 50
#define MAX_HISTORY 10
#define MAX_VAR_NAME 2
#define MAX_SCRIPT_NAME 10
#define MAX_SCRIPT_CMDS 50
#define MAX_FILENAME 256

/* --- Performance Profiling Macros --- */
#define PROFILE_START clock_t _start = clock();
#define PROFILE_END(msg) printf("[%s] Time: %.4f sec\n", msg, (double)(clock() - _start)/CLOCKS_PER_SEC);

/* --- Data Structures --- */
typedef int Trit;
typedef int TritError;  /* Error codes are ints */

typedef struct {
    int sign;
    Trit* digits;
    int len;
    int is_mapped;
    int fd;
    char tmp_path[32];
} TritBigInt;

typedef struct {
    int sign;
    Trit* integer;
    Trit* fraction;
    int i_len, f_len;
    int i_mapped, f_mapped;
    int i_fd, f_fd;
    char i_tmp_path[32];
    char f_tmp_path[32];
} TritFloat;

typedef struct {
    TritFloat real;
    TritFloat imag;
} TritComplex;

typedef struct {
    TritFloat quotient;
    TritFloat remainder;
} TritDivResult;

/* Global State Variables */
static long total_mapped_bytes = 0;
static int operation_steps = 0;
static char* history[MAX_HISTORY] = {0};
static int history_count = 0;
static TritBigInt* variables[26] = {0};

typedef struct {
    char name[MAX_SCRIPT_NAME];
    char commands[MAX_SCRIPT_CMDS][256];
    int cmd_count;
} Script;
static Script scripts[10] = {0};
static int script_count = 0;

/* --- Function Prototypes --- */
TritError tritjs_add_big(TritBigInt* a, TritBigInt* b, TritBigInt** result);
TritError tritjs_subtract_big(TritBigInt* a, TritBigInt* b, TritBigInt** result);
TritError tritjs_multiply_big(TritBigInt* a, TritBigInt* b, TritBigInt** result);
TritError tritjs_divide_big(TritBigInt* a, TritBigInt* b, TritDivResult* result, int precision);
TritError tritjs_power_big(TritBigInt* base, TritBigInt* exp, TritBigInt** result);
TritError tritjs_factorial_big(TritBigInt* a, TritBigInt** result);
TritError tritjs_sqrt_complex(TritBigInt* a, int precision, TritComplex* result);
TritError tritjs_log3_complex(TritBigInt* a, int precision, TritComplex* result);
TritError tritjs_sin_complex(TritBigInt* a, int precision, TritComplex* result);
TritError tritjs_cos_complex(TritBigInt* a, int precision, TritComplex* result);
TritError tritjs_tan_complex(TritBigInt* a, int precision, TritComplex* result);
TritError tritjs_pi(int* len, Trit** pi);
void cleanup_div(TritBigInt* temp_rem, TritFloat* dividend, TritFloat* divisor, TritDivResult* result);
TritError parse_trit_string(const char* str, TritBigInt** bi);
TritError tritbig_from_trits(Trit* trits, int len, int sign, TritBigInt** bi);
void tritbig_free(TritBigInt* bi);
TritError tritfloat_from_bigint(TritBigInt* bi, TritFloat* tf);
void tritfloat_free(TritFloat tf);
TritError tritjs_to_string(TritBigInt* bi, char** str);
TritError tritfloat_to_string(TritFloat tf, char** str);
TritError tritcomplex_to_string(TritComplex tc, char** str);

/* --- Logging and Audit Functions --- */
FILE* audit_log = NULL;
void init_audit_log() {
    audit_log = fopen("/var/log/tritjs_cisa.log", "a");
    if (!audit_log) {
        perror("Audit log initialization failed; defaulting to stderr");
        audit_log = stderr;
    }
}
void log_error(TritError err, const char* context) {
    if (!audit_log) return;
    time_t now;
    time(&now);
    fprintf(audit_log, "[%s] ERROR %d: %s in %s\n", ctime(&now), err, trit_error_str(err), context);
    fflush(audit_log);
}
const char* trit_error_str(TritError err) {
    switch (err) {
        case 0: return "No error";
        case 1: return "Memory allocation failed";
        case 2: return "Invalid input (trits 0-2 only)";
        case 3: return "Division by zero";
        case 4: return "Overflow detected";
        case 5: return "Operation undefined";
        case 6: return "Negative input (complex handled)";
        case 7: return "Precision limit exceeded";
        case 8: return "Memory mapping failed";
        case 9: return "Scripting error";
        default: return "Unknown error";
    }
}

/* --- POSIX-Based map_trits() --- */
TritError map_trits(Trit** digits, int len, int* is_mapped, int* fd, char* tmp_path) {
    if (len * sizeof(Trit) > MAX_MMAP_SIZE) return 4;
    strcpy(tmp_path, "/tmp/tritjs_cisa_XXXXXX");
    *fd = mkstemp(tmp_path);
    if (*fd < 0) return 8;
    ftruncate(*fd, len * sizeof(Trit));
    *digits = mmap(NULL, len * sizeof(Trit), PROT_READ | PROT_WRITE, MAP_SHARED, *fd, 0);
    if (*digits == MAP_FAILED) {
        close(*fd);
        unlink(tmp_path);
        return 8;
    }
    *is_mapped = 1;
    total_mapped_bytes += len * sizeof(Trit);
    operation_steps++;
    display_memory_and_stats("Mapping", "merge");
    unlink(tmp_path);
    return 0;
}

void unmap_trits(Trit* digits, int len, int is_mapped, int fd) {
    if (is_mapped && digits != MAP_FAILED) {
        total_mapped_bytes -= len * sizeof(Trit);
        operation_steps++;
        display_memory_and_stats("Unmapping", "merge");
        munmap(digits, len * sizeof(Trit));
        if (fd >= 0) close(fd);
    } else if (!is_mapped) {
        free(digits);
    }
}

/* --- Arithmetic Operations --- */
TritError tritjs_add_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b || a->len > 1000 || b->len > 1000) return 2;
    int max_len = (a->len > b->len) ? a->len : b->len;
    Trit* temp = calloc(max_len + 1, sizeof(Trit));
    if (!temp) return 1;
    int carry = 0;
    if (a->sign == b->sign) {
        for (int i = max_len - 1, pos = 0; i >= 0; i--, pos++) {
            Trit a_trit = (i < a->len) ? a->digits[i] : 0;
            Trit b_trit = (i < b->len) ? b->digits[i] : 0;
            int sum = a_trit + b_trit + carry;
            temp[max_len - pos] = sum % TRIT_MAX;
            carry = sum / TRIT_MAX;
            operation_steps++;
            display_memory_and_stats("add", "merge");
        }
        if (carry) temp[0] = carry;
        int result_len = carry ? max_len + 1 : max_len;
        if (!carry) memmove(temp, temp + 1, max_len * sizeof(Trit));
        TritError err = tritbig_from_trits(temp, result_len, a->sign, result);
        free(temp);
        return err;
    } else {
        TritBigInt* b_neg;
        TritError err = tritbig_from_trits(b->digits, b->len, !b->sign, &b_neg);
        if (err != 0) { free(temp); return err; }
        err = tritjs_add_big(a, b_neg, result);
        tritbig_free(b_neg);
        free(temp);
        return err;
    }
}

TritError tritjs_subtract_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return 2;
    TritBigInt* b_neg;
    TritError err = tritbig_from_trits(b->digits, b->len, !b->sign, &b_neg);
    if (err != 0) return err;
    err = tritjs_add_big(a, b_neg, result);
    tritbig_free(b_neg);
    return err;
}

TritError tritjs_multiply_big(TritBigInt* a, TritBigInt* b, TritBigInt** result) {
    if (!a || !b) return 2;
    int max_len = a->len + b->len;
    Trit* temp = calloc(max_len, sizeof(Trit));
    if (!temp) return 1;
    for (int i = a->len - 1; i >= 0; i--) {
        int carry = 0;
        for (int j = b->len - 1; j >= 0; j--) {
            int pos = i + j + 1;
            int prod = a->digits[i] * b->digits[j] + temp[pos] + carry;
            temp[pos] = prod % TRIT_MAX;
            carry = prod / TRIT_MAX;
            operation_steps++;
            display_memory_and_stats("mul", "merge");
        }
        if (carry) temp[i] += carry;
    }
    int start = 0;
    while (start < max_len - 1 && temp[start] == 0) start++;
    int sign = (a->sign == b->sign) ? 0 : 1;
    TritError err = tritbig_from_trits(temp + start, max_len - start, sign, result);
    free(temp);
    return err;
}

void cleanup_div(TritBigInt* temp_rem, TritFloat* dividend, TritFloat* divisor, TritDivResult* result) {
    if (temp_rem) tritbig_free(temp_rem);
    if (dividend->integer) tritfloat_free(*dividend);
    if (divisor->integer) tritfloat_free(*divisor);
    if (result->quotient.integer) tritfloat_free(result->quotient);
    if (result->remainder.integer) tritfloat_free(result->remainder);
}

TritError tritjs_divide_big(TritBigInt* a, TritBigInt* b, TritDivResult* result, int precision) {
    TritError err;
    if (!a || !b) return 2;
    if (precision <= 0 || precision > 10) return 7;
    int b_is_zero = 1;
    for (int i = 0; i < b->len; i++) {
        if (b->digits[i] != 0) { b_is_zero = 0; break; }
    }
    if (b_is_zero) return 3;
    TritFloat dividend = {0}, divisor = {0};
    if ((err = tritfloat_from_bigint(a, &dividend)) != 0) return err;
    if ((err = tritfloat_from_bigint(b, &divisor)) != 0) {
        tritfloat_free(dividend);
        return err;
    }
    result->quotient.i_len = a->len;
    result->quotient.f_len = precision;
    result->remainder.i_len = b->len;
    result->quotient.sign = (a->sign == b->sign) ? 0 : 1;
    result->remainder.sign = a->sign;
    if ((err = map_trits(&result->quotient.integer, a->len, &result->quotient.i_mapped, &result->quotient.i_fd, result->quotient.i_tmp_path)) != 0) goto cleanup;
    if ((err = map_trits(&result->quotient.fraction, precision, &result->quotient.f_mapped, &result->quotient.f_fd, result->quotient.f_tmp_path)) != 0) goto cleanup;
    if ((err = map_trits(&result->remainder.integer, b->len, &result->remainder.i_mapped, &result->remainder.i_fd, result->remainder.i_tmp_path)) != 0) goto cleanup;
    TritBigInt* temp_rem = NULL;
    if ((err = tritbig_from_trits(a->digits, a->len, a->sign, &temp_rem)) != 0) goto cleanup;
    for (int i = 0; i < a->len; i++) {
        int digit = 0;
        for (int q = 2; q >= 0; q--) {
            TritBigInt* multiple = NULL;
            Trit trits[] = {(Trit)q};
            if ((err = tritbig_from_trits(trits, 1, 0, &multiple)) != 0) goto cleanup_inner;
            TritBigInt* prod = NULL;
            if ((err = tritjs_multiply_big(b, multiple, &prod)) != 0) {
                tritbig_free(multiple);
                goto cleanup_inner;
            }
            TritBigInt* sub = NULL;
            if ((err = tritjs_subtract_big(temp_rem, prod, &sub)) == 0) {
                digit = q;
                tritbig_free(temp_rem);
                temp_rem = sub;
                tritbig_free(multiple);
                tritbig_free(prod);
                break;
            }
            tritbig_free(multiple);
            tritbig_free(prod);
            operation_steps++;
            display_memory_and_stats("div", "merge");
        }
        result->quotient.integer[i] = digit;
    }
    for (int i = 0; i < precision; i++) {
        TritBigInt* three = NULL;
        if ((err = tritbig_from_trits((Trit[]){1}, 1, 0, &three)) != 0) goto cleanup_inner;
        TritBigInt* temp_mul = NULL;
        if ((err = tritjs_multiply_big(temp_rem, three, &temp_mul)) != 0) {
            tritbig_free(three);
            goto cleanup_inner;
        }
        tritbig_free(temp_rem);
        temp_rem = temp_mul;
        int digit = 0;
        for (int q = 2; q >= 0; q--) {
            TritBigInt* multiple = NULL;
            Trit trits[] = {(Trit)q};
            if ((err = tritbig_from_trits(trits, 1, 0, &multiple)) != 0) goto cleanup_inner;
            TritBigInt* prod = NULL;
            if ((err = tritjs_multiply_big(b, multiple, &prod)) != 0) {
                tritbig_free(multiple);
                goto cleanup_inner;
            }
            TritBigInt* sub = NULL;
            if ((err = tritjs_subtract_big(temp_rem, prod, &sub)) == 0) {
                digit = q;
                tritbig_free(temp_rem);
                temp_rem = sub;
                tritbig_free(multiple);
                tritbig_free(prod);
                break;
            }
            tritbig_free(multiple);
            tritbig_free(prod);
            operation_steps++;
            display_memory_and_stats("div", "merge");
        }
        result->quotient.fraction[i] = digit;
    }
    int start = 0;
    while (start < result->quotient.i_len - 1 && result->quotient.integer[start] == 0) start++;
    if (start > 0) {
        memmove(result->quotient.integer, result->quotient.integer + start, (result->quotient.i_len - start) * sizeof(Trit));
        result->quotient.i_len -= start;
    }
cleanup_inner:
    tritbig_free(temp_rem);
cleanup:
    if (err != 0) {
        tritfloat_free(result->quotient);
        tritfloat_free(result->remainder);
    }
    tritfloat_free(dividend);
    tritfloat_free(divisor);
    return err;
}

TritError tritjs_power_big(TritBigInt* base, TritBigInt* exp, TritBigInt** result) {
    if (!base || !exp) return 2;
    if (exp->sign) return 6;
    TritError err;
    Trit trits[] = {1};
    if ((err = tritbig_from_trits(trits, 1, 0, result)) != 0) return err;
    unsigned long exp_val = 0;
    for (int i = 0; i < exp->len; i++) exp_val = exp_val * TRIT_MAX + exp->digits[i];
    if (exp_val > 1000) {
        tritbig_free(*result);
        return 4;
    }
    int sign = (base->sign && (exp_val % 2)) ? 1 : 0;
    for (unsigned long i = 0; i < exp_val; i++) {
        TritBigInt* temp;
        if ((err = tritjs_multiply_big(*result, base, &temp)) != 0) {
            tritbig_free(*result);
            return err;
        }
        tritbig_free(*result);
        *result = temp;
        operation_steps++;
        display_memory_and_stats("pow", "merge");
    }
    (*result)->sign = sign;
    return 0;
}

TritError tritjs_factorial_big(TritBigInt* a, TritBigInt** result) {
    if (!a) return 2;
    if (a->sign) return 6;
    unsigned long a_val = 0;
    for (int i = 0; i < a->len; i++) a_val = a_val * TRIT_MAX + a->digits[i];
    if (a_val > 20) return 4;
    TritError err;
    Trit trits[] = {1};
    if ((err = tritbig_from_trits(trits, 1, 0, result)) != 0) return err;
    for (unsigned long i = 1; i <= a_val; i++) {
        TritBigInt* i_bi;
        Trit i_trits[2];
        i_trits[0] = i / TRIT_MAX; i_trits[1] = i % TRIT_MAX;
        int len = (i >= TRIT_MAX) ? 2 : 1;
        if ((err = tritbig_from_trits(i_trits + (2 - len), len, 0, &i_bi)) != 0) {
            tritbig_free(*result);
            return err;
        }
        TritBigInt* temp;
        if ((err = tritjs_multiply_big(*result, i_bi, &temp)) != 0) {
            tritbig_free(i_bi);
            tritbig_free(*result);
            return err;
        }
        tritbig_free(*result);
        tritbig_free(i_bi);
        *result = temp;
        operation_steps++;
        display_memory_and_stats("fact", "merge");
    }
    return 0;
}

/* --- Scientific Operations --- */
TritError tritjs_sqrt_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10 || a->len > 1000) return 7;
    unsigned long a_val = 0;
    for (int i = 0; i < a->len; i++) {
        if (a_val > ULONG_MAX / TRIT_MAX) return 4;
        a_val = a_val * TRIT_MAX + a->digits[i];
    }
    double val = (double)a_val * (a->sign ? -1 : 1);
    TritError err;
    if (val >= 0) {
        double sqrt_val = sqrt(val);
        unsigned long int_part = (unsigned long)sqrt_val;
        double frac_part = sqrt_val - int_part;
        Trit* int_trits = calloc((a->len + 1) / 2, sizeof(Trit));
        Trit* frac_trits = calloc(precision, sizeof(Trit));
        if (!int_trits || !frac_trits) {
            free(int_trits); free(frac_trits);
            return 1;
        }
        for (int i = (a->len + 1) / 2 - 1; i >= 0; i--) {
            int_trits[i] = int_part % TRIT_MAX;
            int_part /= TRIT_MAX;
            operation_steps++;
            display_memory_and_stats("sqrt", "merge");
        }
        for (int i = precision - 1; i >= 0; i--) {
            frac_part *= TRIT_MAX;
            frac_trits[i] = (unsigned long)frac_part;
            frac_part -= (unsigned long)frac_part;
            operation_steps++;
            display_memory_and_stats("sqrt", "merge");
        }
        TritBigInt* real_int;
        if ((err = tritbig_from_trits(int_trits, (a->len + 1) / 2, 0, &real_int)) != 0) goto sqrt_cleanup;
        if ((err = tritfloat_from_bigint(real_int, &result->real)) != 0) goto sqrt_cleanup;
        tritbig_free(real_int);
        if ((err = map_trits(&result->real.fraction, precision, &result->real.f_mapped, &result->real.f_fd, result->real.f_tmp_path)) != 0) goto sqrt_cleanup;
        memcpy(result->real.fraction, frac_trits, precision * sizeof(Trit));
        result->real.f_len = precision;
        result->imag.integer = calloc(1, sizeof(Trit));
        if (!result->imag.integer) { err = 1; goto sqrt_cleanup; }
        result->imag.i_len = 1;
        result->imag.i_mapped = 0;
        result->imag.sign = 0;
        result->imag.fraction = NULL;
        result->imag.f_len = 0;
    sqrt_cleanup:
        free(int_trits); free(frac_trits);
        if (err != 0) tritcomplex_free(*result);
        return err;
    } else {
        /* Handling negative input: result is complex */
        double sqrt_val = sqrt(-val);
        unsigned long int_part = (unsigned long)sqrt_val;
        double frac_part = sqrt_val - int_part;
        result->real.integer = calloc(1, sizeof(Trit));
        if (!result->real.integer) return 1;
        result->real.i_len = 1;
        result->real.i_mapped = 0;
        result->real.sign = 0;
        if ((err = map_trits(&result->real.fraction, precision, &result->real.f_mapped, &result->real.f_fd, result->real.f_tmp_path)) != 0) {
            free(result->real.integer);
            return err;
        }
        memset(result->real.fraction, 0, precision * sizeof(Trit));
        result->real.f_len = precision;
        /* For imaginary part, similar conversion as above */
        Trit* imag_int = calloc((a->len + 1) / 2, sizeof(Trit));
        Trit* imag_frac = calloc(precision, sizeof(Trit));
        if (!imag_int || !imag_frac) {
            free(imag_int); free(imag_frac);
            tritfloat_free(result->real);
            return 1;
        }
        for (int i = (a->len + 1) / 2 - 1; i >= 0; i--) {
            imag_int[i] = int_part % TRIT_MAX;
            int_part /= TRIT_MAX;
            operation_steps++;
            display_memory_and_stats("sqrt", "merge");
        }
        for (int i = precision - 1; i >= 0; i--) {
            frac_part *= TRIT_MAX;
            imag_frac[i] = (unsigned long)frac_part;
            frac_part -= (unsigned long)frac_part;
            operation_steps++;
            display_memory_and_stats("sqrt", "merge");
        }
        TritBigInt* imag_bi;
        if ((err = tritbig_from_trits(imag_int, (a->len + 1) / 2, 0, &imag_bi)) != 0) {
            free(imag_int); free(imag_frac);
            tritfloat_free(result->real);
            return err;
        }
        if ((err = tritfloat_from_bigint(imag_bi, &result->imag)) != 0) {
            tritbig_free(imag_bi);
            free(imag_int); free(imag_frac);
            return err;
        }
        tritbig_free(imag_bi);
        if ((err = map_trits(&result->imag.fraction, precision, &result->imag.f_mapped, &result->imag.f_fd, result->imag.f_tmp_path)) != 0) {
            free(imag_int); free(imag_frac);
            tritfloat_free(result->real);
            return err;
        }
        memcpy(result->imag.fraction, imag_frac, precision * sizeof(Trit));
        result->imag.f_len = precision;
        free(imag_int); free(imag_frac);
        return 0;
    }
}

TritError tritjs_log3_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10) return 7;
    unsigned long a_val = 0;
    for (int i = 0; i < a->len; i++) a_val = a_val * TRIT_MAX + a->digits[i];
    double real = (double)a_val * (a->sign ? -1 : 1);
    double imag = 0;
    double mag = sqrt(real * real + imag * imag);
    double arg = atan2(imag, real);
    double ln3 = log(3.0);
    double real_val = log(mag) / ln3;
    double imag_val = arg / ln3;
    TritError err;
    Trit* real_int = calloc(a->len, sizeof(Trit));
    Trit* real_frac = calloc(precision, sizeof(Trit));
    Trit* imag_int = calloc(a->len, sizeof(Trit));
    Trit* imag_frac = calloc(precision, sizeof(Trit));
    if (!real_int || !real_frac || !imag_int || !imag_frac) {
        free(real_int); free(real_frac); free(imag_int); free(imag_frac);
        return 1;
    }
    unsigned long r_int_part = (unsigned long)fabs(real_val);
    double r_frac_part = fabs(real_val) - r_int_part;
    for (int i = a->len - 1; i >= 0; i--) {
        real_int[i] = r_int_part % TRIT_MAX;
        r_int_part /= TRIT_MAX;
        operation_steps++;
        display_memory_and_stats("log3", "merge");
    }
    for (int i = precision - 1; i >= 0; i--) {
        r_frac_part *= TRIT_MAX;
        real_frac[i] = (unsigned long)r_frac_part;
        r_frac_part -= (unsigned long)r_frac_part;
        operation_steps++;
        display_memory_and_stats("log3", "merge");
    }
    TritBigInt* real_bi;
    if ((err = tritbig_from_trits(real_int, a->len, real_val < 0 ? 1 : 0, &real_bi)) != 0) goto log_cleanup;
    if ((err = tritfloat_from_bigint(real_bi, &result->real)) != 0) goto log_cleanup;
    tritbig_free(real_bi);
    if ((err = map_trits(&result->real.fraction, precision, &result->real.f_mapped, &result->real.f_fd, result->real.f_tmp_path)) != 0) goto log_cleanup;
    memcpy(result->real.fraction, real_frac, precision * sizeof(Trit));
    result->real.f_len = precision;
    unsigned long i_int_part = (unsigned long)fabs(imag_val);
    double i_frac_part = fabs(imag_val) - i_int_part;
    for (int i = a->len - 1; i >= 0; i--) {
        imag_int[i] = i_int_part % TRIT_MAX;
        i_int_part /= TRIT_MAX;
        operation_steps++;
        display_memory_and_stats("log3", "merge");
    }
    for (int i = precision - 1; i >= 0; i--) {
        i_frac_part *= TRIT_MAX;
        imag_frac[i] = (unsigned long)i_frac_part;
        i_frac_part -= (unsigned long)i_frac_part;
        operation_steps++;
        display_memory_and_stats("log3", "merge");
    }
    TritBigInt* imag_bi;
    if ((err = tritbig_from_trits(imag_int, a->len, imag_val < 0 ? 1 : 0, &imag_bi)) != 0) goto log_cleanup;
    if ((err = tritfloat_from_bigint(imag_bi, &result->imag)) != 0) goto log_cleanup;
    tritbig_free(imag_bi);
    if ((err = map_trits(&result->imag.fraction, precision, &result->imag.f_mapped, &result->imag.f_fd, result->imag.f_tmp_path)) != 0) goto log_cleanup;
    memcpy(result->imag.fraction, imag_frac, precision * sizeof(Trit));
    result->imag.f_len = precision;
log_cleanup:
    free(real_int); free(real_frac); free(imag_int); free(imag_frac);
    if (err != 0) tritcomplex_free(*result);
    return err;
}

TritError tritjs_trig_complex(TritBigInt* a, int precision, TritComplex* result, double (*trig_func)(double)) {
    if (!a || precision <= 0 || precision > 10) return 7;
    unsigned long a_val = 0;
    for (int i = 0; i < a->len; i++) a_val = a_val * TRIT_MAX + a->digits[i];
    double pi_approx = 3.1415926535;
    double angle = (double)a_val * pi_approx / 10.0 * (a->sign ? -1 : 1);
    double trig_val = trig_func(angle);
    int sign = trig_val < 0 ? 1 : 0;
    double abs_val = fabs(trig_val);
    unsigned long int_part = (unsigned long)abs_val;
    double frac_part = abs_val - int_part;
    TritError err;
    Trit* int_trits = calloc(1, sizeof(Trit));
    Trit* frac_trits = calloc(precision, sizeof(Trit));
    if (!int_trits || !frac_trits) {
        free(int_trits); free(frac_trits);
        return 1;
    }
    int_trits[0] = int_part % TRIT_MAX;
    for (int i = precision - 1; i >= 0; i--) {
        frac_part *= TRIT_MAX;
        frac_trits[i] = (unsigned long)frac_part;
        frac_part -= (unsigned long)frac_part;
        operation_steps++;
        display_memory_and_stats("trig", "merge");
    }
    TritBigInt* real_bi;
    if ((err = tritbig_from_trits(int_trits, 1, sign, &real_bi)) != 0) goto trig_cleanup;
    if ((err = tritfloat_from_bigint(real_bi, &result->real)) != 0) goto trig_cleanup;
    tritbig_free(real_bi);
    if ((err = map_trits(&result->real.fraction, precision, &result->real.f_mapped, &result->real.f_fd, result->real.f_tmp_path)) != 0) goto trig_cleanup;
    memcpy(result->real.fraction, frac_trits, precision * sizeof(Trit));
    result->real.f_len = precision;
    result->imag.integer = calloc(1, sizeof(Trit));
    if (!result->imag.integer) { err = 1; goto trig_cleanup; }
    result->imag.i_len = 1;
    result->imag.i_mapped = 0;
    result->imag.sign = 0;
    result->imag.fraction = NULL;
    result->imag.f_len = 0;
trig_cleanup:
    free(int_trits); free(frac_trits);
    if (err != 0) tritcomplex_free(*result);
    return err;
}

TritError tritjs_sin_complex(TritBigInt* a, int precision, TritComplex* result) {
    return tritjs_trig_complex(a, precision, result, sin);
}

TritError tritjs_cos_complex(TritBigInt* a, int precision, TritComplex* result) {
    return tritjs_trig_complex(a, precision, result, cos);
}

TritError tritjs_tan_complex(TritBigInt* a, int precision, TritComplex* result) {
    if (!a || precision <= 0 || precision > 10) return 7;
    unsigned long a_val = 0;
    for (int i = 0; i < a->len; i++) a_val = a_val * TRIT_MAX + a->digits[i];
    double pi_approx = 3.1415926535;
    double angle = (double)a_val * pi_approx / 10.0 * (a->sign ? -1 : 1);
    double tan_val = tan(angle);
    if (fabs(tan_val) > 1000.0) return 5;
    return tritjs_trig_complex(a, precision, result, tan);
}

TritError tritjs_pi(int* len, Trit** pi) {
    Trit pi_val[] = {1, 0, 0, 1, 0, 2, 2, 1};
    *len = 8;
    *pi = malloc(*len * sizeof(Trit));
    if (!*pi) return 1;
    memcpy(*pi, pi_val, *len * sizeof(Trit));
    operation_steps++;
    display_memory_and_stats("pi", "merge");
    return 0;
}

/* --- Utility Functions --- */
TritError parse_trit_string(const char* str, TritBigInt** bi) {
    if (!str || !strlen(str)) return 2;
    if (strlen(str) > 256) return 2;
    int sign = (str[0] == '-') ? 1 : 0;
    const char* mag = sign ? str + 1 : str;
    int len = strlen(mag);
    Trit* trits = malloc(len * sizeof(Trit));
    if (!trits) return 1;
    for (int i = 0; i < len; i++) {
        if (mag[i] < '0' || mag[i] > '2') {
            free(trits);
            fprintf(stderr, "parse_trit_string: Invalid character '%c'\n", mag[i]);
            return 2;
        }
        trits[i] = mag[i] - '0';
    }
    TritError err = tritbig_from_trits(trits, len, sign, bi);
    free(trits);
    return err;
}

TritError tritjs_to_string(TritBigInt* bi, char** str) {
    if (!bi || bi->len <= 0) return 2;
    *str = malloc(bi->len + 1 + (bi->sign ? 1 : 0));
    if (!*str) return 1;
    char* p = *str;
    if (bi->sign) *p++ = '-';
    for (int i = 0; i < bi->len; i++) *p++ = '0' + bi->digits[i];
    *p = '\0';
    return 0;
}

TritError tritfloat_to_string(TritFloat tf, char** str) {
    if (!tf.integer || tf.i_len <= 0) return 2;
    int total_len = tf.i_len + (tf.f_len > 0 ? tf.f_len + 1 : 0) + (tf.sign ? 1 : 0);
    *str = malloc(total_len + 1);
    if (!*str) return 1;
    char* p = *str;
    if (tf.sign) *p++ = '-';
    for (int i = 0; i < tf.i_len; i++) *p++ = '0' + tf.integer[i];
    if (tf.f_len > 0) {
        *p++ = '.';
        for (int i = 0; i < tf.f_len; i++) *p++ = '0' + tf.fraction[i];
    }
    *p = '\0';
    return 0;
}

TritError tritcomplex_to_string(TritComplex tc, char** str) {
    char* real_str, *imag_str;
    TritError err;
    if ((err = tritfloat_to_string(tc.real, &real_str)) != 0) return err;
    if ((err = tritfloat_to_string(tc.imag, &imag_str)) != 0) {
        free(real_str);
        return err;
    }
    int imag_zero = (tc.imag.i_len == 1 && tc.imag.integer[0] == 0 && tc.imag.f_len == 0);
    if (imag_zero) {
        *str = real_str;
        free(imag_str);
        return 0;
    }
    *str = malloc(strlen(real_str) + strlen(imag_str) + 4);
    if (!*str) {
        free(real_str);
        free(imag_str);
        return 1;
    }
    sprintf(*str, "%s %si", real_str, imag_str);
    free(real_str);
    free(imag_str);
    return 0;
}

/* --- Binary/Trinary Conversion Functions --- */
TritError binary_to_trit(int num, TritBigInt** result) {
    int sign = (num < 0) ? 1 : 0;
    int abs_val = (num < 0) ? -num : num;
    if (abs_val == 0) {
        *result = malloc(sizeof(TritBigInt));
        if (!*result) return 1;
        (*result)->sign = 0;
        (*result)->len = 1;
        (*result)->digits = malloc(sizeof(Trit));
        if (!(*result)->digits) { free(*result); return 1; }
        (*result)->digits[0] = 0;
        (*result)->is_mapped = 0;
        return 0;
    }
    int capacity = 16;
    Trit* digits = malloc(capacity * sizeof(Trit));
    if (!digits) return 1;
    int index = 0;
    while (abs_val > 0) {
        if (index >= capacity) {
            capacity *= 2;
            Trit* new_digits = realloc(digits, capacity * sizeof(Trit));
            if (!new_digits) { free(digits); return 1; }
            digits = new_digits;
        }
        digits[index++] = abs_val % TRIT_MAX;
        abs_val /= TRIT_MAX;
    }
    for (int i = 0; i < index/2; i++) {
        Trit temp = digits[i];
        digits[i] = digits[index - i - 1];
        digits[index - i - 1] = temp;
    }
    *result = malloc(sizeof(TritBigInt));
    if (!*result) { free(digits); return 1; }
    (*result)->sign = sign;
    (*result)->len = index;
    (*result)->digits = digits;
    (*result)->is_mapped = 0;
    return 0;
}

TritError trit_to_binary(TritBigInt* tri, int* result) {
    if (!tri || !result) return 2;
    int value = 0;
    for (int i = 0; i < tri->len; i++) {
        value = value * TRIT_MAX + tri->digits[i];
    }
    if (tri->sign) value = -value;
    *result = value;
    return 0;
}

/* --- Enhanced CLI Commands --- */
TritError execute_command(const char* input, int is_script) {
    char op[10], arg1[256], arg2[256] = "";
    int parsed = sscanf(input, "%9s %255s %255s", op, arg1, arg2);
    if (parsed < 2 || strlen(arg1) > 255 || (arg2[0] && strlen(arg2) > 255)) {
        if (!is_script) printf("Error: Input too long or invalid format\n");
        return 2;
    }
    /* New commands: bin2tri and tri2bin */
    if (strncmp(input, "bin2tri", 7) == 0) {
        int num;
        if (sscanf(input + 7, "%d", &num) != 1) {
            if (!is_script) printf("Error: Invalid binary number\n");
            return 2;
        }
        TritBigInt* tri;
        TritError err = binary_to_trit(num, &tri);
        if (err == 0) {
            char* str;
            if ((err = tritjs_to_string(tri, &str)) == 0) {
                if (!is_script) printf("Trinary: %s\n", str);
                add_to_history(str);
                free(str);
            }
            tritbig_free(tri);
        }
        return err;
    }
    if (strncmp(input, "tri2bin", 7) == 0) {
        char trit_str[256];
        if (sscanf(input + 7, "%255s", trit_str) != 1) {
            if (!is_script) printf("Error: Invalid trinary input\n");
            return 2;
        }
        TritBigInt* tri;
        TritError err = parse_trit_string(trit_str, &tri);
        if (err == 0) {
            int num;
            trit_to_binary(tri, &num);
            if (!is_script) printf("Binary: %d\n", num);
            char buf[256];
            snprintf(buf, sizeof(buf), "%d", num);
            add_to_history(buf);
            tritbig_free(tri);
        }
        return err;
    }
    /* Existing command processing */
    TritBigInt* a = NULL;
    TritBigInt* b = NULL;
    TritError err;
    if (strchr(arg1, '=') && !arg2[0]) {
        char var_name[2] = {arg1[0], '\0'};
        char* value = strchr(arg1, '=') + 1;
        if ((err = parse_trit_string(value, &a)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
            return err;
        }
        store_variable(var_name, a);
        if (!is_script) printf("%s stored\n", var_name);
        return 0;
    }
    if (arg1[0] >= 'A' && arg1[0] <= 'Z' && arg1[1] == '\0') {
        a = recall_variable(arg1);
        if (!a) {
            if (!is_script) printf("Error: Variable %s not set\n", arg1);
            return 2;
        }
    } else if ((err = parse_trit_string(arg1, &a)) != 0) {
        if (!is_script) printf("Error: %s\n", trit_error_str(err));
        return err;
    }
    if (strlen(arg2) > 0) {
        if (arg2[0] >= 'A' && arg2[0] <= 'Z' && arg2[1] == '\0') {
            b = recall_variable(arg2);
            if (!b) {
                if (!is_script) printf("Error: Variable %s not set\n", arg2);
                tritbig_free(a);
                return 2;
            }
        } else if ((err = parse_trit_string(arg2, &b)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
            tritbig_free(a);
            return err;
        }
    }
    if (strcmp(op, "add") == 0 && b) {
        TritBigInt* result;
        if ((err = tritjs_add_big(a, b, &result)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* str;
            if ((err = tritjs_to_string(result, &str)) == 0) {
                if (!is_script) {
                    printf("%s\n", str);
                    add_to_history(str);
                }
                free(str);
            }
            tritbig_free(result);
        }
    } else if (strcmp(op, "sub") == 0 && b) {
        TritBigInt* result;
        if ((err = tritjs_subtract_big(a, b, &result)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* str;
            if ((err = tritjs_to_string(result, &str)) == 0) {
                if (!is_script) {
                    printf("%s\n", str);
                    add_to_history(str);
                }
                free(str);
            }
            tritbig_free(result);
        }
    } else if (strcmp(op, "mul") == 0 && b) {
        TritBigInt* result;
        if ((err = tritjs_multiply_big(a, b, &result)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* str;
            if ((err = tritjs_to_string(result, &str)) == 0) {
                if (!is_script) {
                    printf("%s\n", str);
                    add_to_history(str);
                }
                free(str);
            }
            tritbig_free(result);
        }
    } else if (strcmp(op, "div") == 0 && b) {
        TritDivResult result = {{0}, {0}};
        if ((err = tritjs_divide_big(a, b, &result, 3)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* q_str, *r_str;
            if ((err = tritfloat_to_string(result.quotient, &q_str)) == 0 &&
                (err = tritfloat_to_string(result.remainder, &r_str)) == 0) {
                char full_result[512];
                snprintf(full_result, sizeof(full_result), "%s r %s", q_str, r_str);
                if (!is_script) {
                    printf("%s\n", full_result);
                    add_to_history(full_result);
                }
                free(q_str);
                free(r_str);
            }
            tritfloat_free(result.quotient);
            tritfloat_free(result.remainder);
        }
    } else if (strcmp(op, "pow") == 0 && b) {
        TritBigInt* result;
        if ((err = tritjs_power_big(a, b, &result)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* str;
            if ((err = tritjs_to_string(result, &str)) == 0) {
                if (!is_script) {
                    printf("%s\n", str);
                    add_to_history(str);
                }
                free(str);
            }
            tritbig_free(result);
        }
    } else if (strcmp(op, "fact") == 0) {
        TritBigInt* result;
        if ((err = tritjs_factorial_big(a, &result)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* str;
            if ((err = tritjs_to_string(result, &str)) == 0) {
                if (!is_script) {
                    printf("%s\n", str);
                    add_to_history(str);
                }
                free(str);
            }
            tritbig_free(result);
        }
    } else if (strcmp(op, "sqrt") == 0) {
        TritComplex result;
        if ((err = tritjs_sqrt_complex(a, 3, &result)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* str;
            if ((err = tritcomplex_to_string(result, &str)) == 0) {
                if (!is_script) {
                    printf("%s\n", str);
                    add_to_history(str);
                }
                free(str);
            }
            tritcomplex_free(result);
        }
    } else if (strcmp(op, "log3") == 0) {
        TritComplex result;
        if ((err = tritjs_log3_complex(a, 3, &result)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* str;
            if ((err = tritcomplex_to_string(result, &str)) == 0) {
                if (!is_script) {
                    printf("%s\n", str);
                    add_to_history(str);
                }
                free(str);
            }
            tritcomplex_free(result);
        }
    } else if (strcmp(op, "sin") == 0) {
        TritComplex result;
        if ((err = tritjs_sin_complex(a, 3, &result)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* str;
            if ((err = tritcomplex_to_string(result, &str)) == 0) {
                if (!is_script) {
                    printf("%s\n", str);
                    add_to_history(str);
                }
                free(str);
            }
            tritcomplex_free(result);
        }
    } else if (strcmp(op, "cos") == 0) {
        TritComplex result;
        if ((err = tritjs_cos_complex(a, 3, &result)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* str;
            if ((err = tritcomplex_to_string(result, &str)) == 0) {
                if (!is_script) {
                    printf("%s\n", str);
                    add_to_history(str);
                }
                free(str);
            }
            tritcomplex_free(result);
        }
    } else if (strcmp(op, "tan") == 0) {
        TritComplex result;
        if ((err = tritjs_tan_complex(a, 3, &result)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* str;
            if ((err = tritcomplex_to_string(result, &str)) == 0) {
                if (!is_script) {
                    printf("%s\n", str);
                    add_to_history(str);
                }
                free(str);
            }
            tritcomplex_free(result);
        }
    } else if (strcmp(op, "pi") == 0) {
        int len;
        Trit* pi;
        if ((err = tritjs_pi(&len, &pi)) != 0) {
            if (!is_script) printf("Error: %s\n", trit_error_str(err));
        } else {
            char* str = malloc(len + 1);
            if (str) {
                for (int i = 0; i < len; i++) str[i] = '0' + pi[i];
                str[len] = '\0';
                if (!is_script) {
                    printf("%s\n", str);
                    add_to_history(str);
                }
                free(str);
            }
            free(pi);
        }
    } else {
        if (!is_script) printf("Error: Unknown command\n");
        err = 2;
    }
    if (a && !(arg1[0] >= 'A' && arg1[0] <= 'Z' && arg1[1] == '\0')) tritbig_free(a);
    if (b && !(arg2[0] >= 'A' && arg2[0] <= 'Z' && arg2[1] == '\0')) tritbig_free(b);
    return err;
}

/* --- Script Execution Functions --- */
TritError run_script(Script* script) {
    for (int i = 0; i < script->cmd_count; i++) {
        char* cmd = script->commands[i];
        if (strncmp(cmd, "IF ", 3) == 0) {
            char cond[256], then_cmd[256];
            if (sscanf(cmd, "IF %255s THEN %255[^\n]", cond, then_cmd) != 2) {
                printf("Script Error: Invalid IF syntax\n");
                return 9;
            }
            TritBigInt* cond_val;
            if (parse_trit_string(cond, &cond_val) != 0) {
                printf("Script Error: Invalid condition\n");
                return 9;
            }
            int val = 0;
            for (int j = 0; j < cond_val->len; j++) val = val * TRIT_MAX + cond_val->digits[j];
            tritbig_free(cond_val);
            if (val != 0) {
                if (execute_command(then_cmd, 1) != 0) return 9;
            }
        } else if (strncmp(cmd, "FOR ", 4) == 0) {
            char var[2], start_str[256], end_str[256], loop_cmd[256];
            if (sscanf(cmd, "FOR %1s %255s %255s %255[^\n]", var, start_str, end_str, loop_cmd) != 4) {
                printf("Script Error: Invalid FOR syntax\n");
                return 9;
            }
            TritBigInt *start, *end;
            if (parse_trit_string(start_str, &start) != 0 || parse_trit_string(end_str, &end) != 0) {
                printf("Script Error: Invalid FOR range\n");
                return 9;
            }
            int start_val = 0, end_val = 0;
            for (int j = 0; j < start->len; j++) start_val = start_val * TRIT_MAX + start->digits[j];
            for (int j = 0; j < end->len; j++) end_val = end_val * TRIT_MAX + end->digits[j];
            for (int k = start_val; k <= end_val; k++) {
                char val_str[10];
                snprintf(val_str, sizeof(val_str), "%d", k);
                TritBigInt* i_bi;
                if (parse_trit_string(val_str, &i_bi) != 0) {
                    tritbig_free(start);
                    tritbig_free(end);
                    return 9;
                }
                store_variable(var, i_bi);
                if (execute_command(loop_cmd, 1) != 0) {
                    tritbig_free(start);
                    tritbig_free(end);
                    return 9;
                }
            }
            tritbig_free(start);
            tritbig_free(end);
        } else {
            if (execute_command(cmd, 1) != 0) return 9;
        }
    }
    return 0;
}

/* --- Test Suite --- */
void run_tests() {
    printf("Running tests...\n");
    PROFILE_START
    /* Test: binary_to_trit and trit_to_binary conversion */
    TritBigInt* test_tri = NULL;
    if (binary_to_trit(42, &test_tri) != 0) {
        printf("Test bin2tri FAILED\n");
    } else {
        int bin;
        trit_to_binary(test_tri, &bin);
        if (bin == 42)
            printf("Test bin2tri / tri2bin PASSED\n");
        else
            printf("Test bin2tri / tri2bin FAILED\n");
        tritbig_free(test_tri);
    }
    /* Test: parse_trit_string */
    TritBigInt* test_bi = NULL;
    if (parse_trit_string("120", &test_bi) != 0) {
        printf("Test parse_trit_string FAILED\n");
    } else {
        char* s = NULL;
        tritjs_to_string(test_bi, &s);
        if (s && strcmp(s, "120") == 0)
            printf("Test parse_trit_string PASSED\n");
        else
            printf("Test parse_trit_string FAILED\n");
        free(s);
        tritbig_free(test_bi);
    }
    PROFILE_END("Tests")
}

/* --- Input Handling --- */
char* get_input(const char* prompt) {
#ifdef USE_READLINE
    char* input = readline(prompt);
    if (input && *input)
        add_history(input);
    return input;
#else
    static char buf[256];
    printf("%s", prompt);
    if (fgets(buf, sizeof(buf), stdin))
        buf[strcspn(buf, "\n")] = 0;
    return buf;
#endif
}

/* --- Main CLI Loop --- */
void print_help() {
    printf("\n=== TritJS-CISA Commands ===\n");
    printf("Arithmetic:\n  add <a> <b>  - Add two ternary numbers\n  sub <a> <b>  - Subtract b from a\n  mul <a> <b>  - Multiply a and b\n  div <a> <b>  - Divide a by b\n  pow <a> <b>  - Raise a to power b\n  fact <a>     - Factorial of a\n");
    printf("Scientific:\n  sqrt <a>     - Square root of a\n  log3 <a>     - Base-3 logarithm of a\n  sin <a>      - Sine of a\n  cos <a>      - Cosine of a\n  tan <a>      - Tangent of a\n  pi           - Pi in base-3\n");
    printf("Stats:\n  stats [quick|merge] - Show mean, mode, median (auto-selects if omitted)\n");
    printf("Memory:\n  <A-Z>=<val>  - Store value in variable (e.g., A=12)\n  recall <n>   - Recall nth last result (0 = latest)\n  clear        - Clear history, variables, and scripts\n");
    printf("Storage:\n  save <file>  - Save state to file (.trit)\n  load <file>  - Load state from file (.trit)\n");
    printf("Scripting:\n  PROG <name> {<cmds>} - Define script (e.g., PROG LOOP {add A 1; A=A})\n  RUN <name>   - Run named script\n");
    printf("Conversion:\n  bin2tri <number> - Convert binary integer to trinary representation\n  tri2bin <trit>   - Convert trinary number to binary integer\n");
    printf("General:\n  help         - Show this help\n  quit         - Exit\n  test         - Run built-in tests\n");
    printf("====================\n");
}

void run_calculator() {
    init_audit_log();
    printf("=== TritJS-CISA Ternary Calculator ===\n");
    printf("Type 'help' for commands\n");
    while (1) {
        total_mapped_bytes = 0;
        operation_steps = 0;
        char* input = get_input("> ");
#ifdef USE_READLINE
        if (!input) break;
#else
        if (strlen(input) == 0) continue;
#endif
        if (audit_log) fprintf(audit_log, "[%ld] Command: %s\n", time(NULL), input);
        if (strcmp(input, "quit") == 0) break;
        if (strcmp(input, "help") == 0) {
            print_help();
#ifdef USE_READLINE
            free(input);
#endif
            continue;
        }
        if (strcmp(input, "clear") == 0) {
            clear_history_and_vars();
            printf("History, variables, and scripts cleared\n");
#ifdef USE_READLINE
            free(input);
#endif
            continue;
        }
        if (strcmp(input, "test") == 0) {
            run_tests();
#ifdef USE_READLINE
            free(input);
#endif
            continue;
        }
        if (strncmp(input, "stats", 5) == 0) {
            char sort_method[10] = "auto";
            sscanf(input, "%*s %9s", sort_method);
            if (strcmp(sort_method, "quick") && strcmp(sort_method, "merge") && strcmp(sort_method, "auto")) {
                printf("Error: Sort method must be 'quick', 'merge', or omitted (auto)\n");
#ifdef USE_READLINE
                free(input);
#endif
                continue;
            }
            double mean = 0.0;
            int trit_counts[TRIT_MAX] = {0}, max_count = 0, mode = -1, total_trits = 0;
            int* all_trits = NULL;
            for (int i = 0; i < history_count; i++) {
                TritBigInt* bi;
                if (parse_trit_string(history[i], &bi) == 0) {
                    all_trits = realloc(all_trits, (total_trits + bi->len) * sizeof(int));
                    for (int j = 0; j < bi->len; j++) {
                        mean += bi->digits[j];
                        trit_counts[bi->digits[j]]++;
                        all_trits[total_trits + j] = bi->digits[j];
                    }
                    total_trits += bi->len;
                    tritbig_free(bi);
                }
            }
            if (total_trits > 0) mean /= total_trits;
            for (int i = 0; i < TRIT_MAX; i++) {
                if (trit_counts[i] > max_count) {
                    max_count = trit_counts[i];
                    mode = i;
                }
            }
            double median = -1;
            if (total_trits > 0) {
                const char* chosen_method = sort_method;
                if (strcmp(sort_method, "auto") == 0) {
                    chosen_method = (total_trits < 10) ? "quick" : "merge";
                }
                if (strcmp(chosen_method, "quick") == 0)
                    quicksort(all_trits, 0, total_trits - 1);
                else
                    trit_mergesort(all_trits, 0, total_trits - 1);
                median = (total_trits % 2 == 0) ? (all_trits[total_trits / 2 - 1] + all_trits[total_trits / 2]) / 2.0 : all_trits[total_trits / 2];
            }
            free(all_trits);
            printf("Stats - Mean: %.2f | Mode: %d | Median: %.2f\n", mean, mode, median);
#ifdef USE_READLINE
            free(input);
#endif
            continue;
        }
        execute_command(input, 0);
#ifdef USE_READLINE
        free(input);
#endif
    }
}

int main() {
    run_calculator();
    return 0;
}
