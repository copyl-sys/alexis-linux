@* USER MANUAL (preserved from original and updated):
 *
 * @* TritJS-CISA: A Ternary Calculator with CISA-Compliant Security, POSIX Enhancements, 
 * Comprehensive Benchmarking, and an Enhanced Ncurses Interface.
 *
 * This program has been optimized for:
 *   - Improved memory management and safe dynamic reallocation.
 *   - Faster base conversion by grouping four base‑3 digits at a time.
 *   - Efficient multiplication using a Karatsuba algorithm (with fallback to naïve multiplication for small inputs).
 *   - Enhanced security including file locking on audit logs and secure memory zeroing (where supported) via FIPS–validated crypto.
 *   - Real-time intrusion detection using a background monitoring thread.
 *   - Extended scripting by embedding Lua.
 *   - A responsive ncurses UI with color support and dynamic resizing.
 *   - Extended ternary operations including:
 *       • Full division and modulo (long division algorithm)
 *       • Left/right shift operations.
 *       • Ternary logical functions (AND, OR, NOT, XOR)
 *       • Parsing for balanced ternary input.
 *
 * == Features ==
 * • Arithmetic: add, sub, mul, div, pow, fact
 * • Scientific: sqrt, log3, sin, cos, tan, pi (via double conversion)
 * • Conversions: bin2tri, tri2bin, balanced-to-unbalanced and vice versa (complete conversion routines)
 * • State Management: save and load encrypted/signed session states
 * • Security: secure audit logging (with file locking) and secure memory clearing
 * • Benchmarking: bench command runs performance tests
 * • Scripting & Variables: PROG/RUN, A=102, IF, FOR, plus Lua scripting support
 * • Interface: enhanced ncurses-based UI (with color and terminal resize support)
 * • Extended Ternary Operations: full division/modulo, left/right shift, ternary logical operations,
 *   and balanced ternary parsing.
 *
 * == Installation ==
 * 1. Compile using:
 *      gcc -DUSE_READLINE -o tritjs_cisa_optimized_ext TritJS-CISA-Optimized_Extended.cweb -lm -lreadline \
 *          -fstack-protector-strong -D_FORTIFY_SOURCE=2 -pie -fPIE -lncurses -lcrypto -lpthread -llua
 * 2. Run with:
 *      ./tritjs_cisa_optimized_ext
 *
 * == Command Reference ==
 *  add <a> <b>, sub <a> <b>, mul <a> <b>, div <a> <b>, pow <a> <b>, fact <a>
 *  sqrt <a>, log3 <a>, sin <a>, cos <a>, tan <a>, pi
 *  bin2tri <n>, tri2bin <trit>, bal2unb <balanced>, unb2bal <unbalanced>
 *  lshift <a> <shift>, rshift <a> <shift>
 *  and <a> <b>, or <a> <b>, not <a>, xor <a> <b>
 *  save <file>, load <file>
 *  monitor, bench
 *  PROG <name> { <commands> }, RUN <name>, <var>=<value>, help, clear, test, version, quit
 *
 * == Troubleshooting ==
 * - Audit Log: /var/log/tritjs_cisa.log (secured with file locking)
 * - Must be root to load states
 * - 1MB limit for mapped trits; benchmark outputs are provided for performance analysis.
 *
 * == Future Enhancements ==
 * - Further FIPS–validated crypto integration, real-time intrusion detection enhancements,
 *   extended scripting with more features, and additional UI improvements.
 *
 * == License ==
 * GNU General Public License (GPL)
@x
/***********************************************************************
 * TritJS-CISA-Optimized_Extended: A Ternary Calculator with Advanced Features
 *
 * This literate source file integrates:
 *   - FIPS–validated crypto using OpenSSL AES‑256‑GCM,
 *   - Real-time intrusion detection (via a background monitoring thread),
 *   - Embedded Lua for extended scripting,
 *   - Enhanced ncurses UI (with color and dynamic resizing),
 *   - And additional full implementations for ternary operations:
 *       • Full division/modulo (long division algorithm)
 *       • Left/right shift operations
 *       • Ternary logical operations (AND, OR, NOT, XOR)
 *       • Balanced ternary parsing (supporting “-”/“–”, “0”, “+” input)
 ***********************************************************************/
@+

@* Section 1. Preliminaries and Includes
@c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>
#include <limits.h>
#include <ncurses.h>
#ifdef USE_READLINE
#include <readline/readline.h>
#include <readline/history.h>
#endif
#include <errno.h>
#include <sys/file.h>  /* for flock */
#include <openssl/evp.h>
#include <pthread.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

#define ENABLE_VERBOSE_LOGGING 1
#define VERSION "2.0-upgrade-optimized"

/* Base definitions */
#define BASE_81 81
#define T81_MMAP_THRESHOLD (500 * 1024)

/* Error codes: 0=OK, 1=MemAlloc, 2=InvalidInput, 3=DivZero, 4=Overflow,
   5=Undefined, 6=Negative, 7=PrecisionErr, 8=MMapFail, 9=ScriptErr */
typedef int TritError;
#if ENABLE_VERBOSE_LOGGING
#define LOG_ERROR(err, context) log_error(err, context, __FILE__, __LINE__)
#else
#define LOG_ERROR(err, context) log_error(err, context)
#endif

/* Data Structures */
typedef struct {
    int sign;                 /* 0 = positive, 1 = negative */
    unsigned char *digits;    /* Array of base‑81 digits (little-endian) */
    size_t len;               /* Number of digits */
    int is_mapped;            /* 1 if allocated with mmap */
    int fd;                   /* File descriptor (if using mmap) */
    char tmp_path[32];        /* Temporary file path */
} T81BigInt;

typedef struct {
    int sign;
    unsigned char* integer;   /* Base‑81 digits for integer part */
    unsigned char* fraction;  /* Base‑81 digits for fractional part */
    size_t i_len, f_len;
    int i_mapped, f_mapped;
    int i_fd, f_fd;
    char i_tmp_path[32];
    char f_tmp_path[32];
} T81Float;

typedef struct {
    T81Float real;
    T81Float imag;
} T81Complex;

typedef struct {
    T81Float quotient;
    T81Float remainder;
} T81DivResult;

#define MAX_SCRIPT_NAME 10
#define MAX_SCRIPT_CMDS 50
typedef struct {
    char name[MAX_SCRIPT_NAME];
    char commands[MAX_SCRIPT_CMDS][256];
    int cmd_count;
} Script;
@c
/* Global Variables */
static FILE* audit_log = NULL;
static long total_mapped_bytes = 0;
static int operation_steps = 0;

#define MAX_HISTORY 10
static char* history[MAX_HISTORY] = {0};
static int history_count = 0;

static T81BigInt* variables[26] = {0};
static Script scripts[10] = {0};
static int script_count = 0;

static WINDOW *input_win, *output_win, *status_win;
@-Preliminaries

@* Section 2. Logging and Error Handling
@c
static const char* trit_error_str(TritError err) {
    switch(err){
        case 0: return "No error";
        case 1: return "Memory allocation failed";
        case 2: return "Invalid input";
        case 3: return "Division by zero";
        case 4: return "Overflow detected";
        case 5: return "Operation undefined";
        case 6: return "Negative input";
        case 7: return "Precision limit exceeded";
        case 8: return "Memory mapping failed";
        case 9: return "Script error";
        default: return "Unknown error";
    }
}

static void log_error(TritError err, const char* context, const char* file, int line) {
    if (!audit_log) return;
    time_t now;
    time(&now);
    fprintf(audit_log, "[%s] ERROR %d: %s in %s (%s:%d)\n",
            ctime(&now), err, trit_error_str(err), context, file, line);
    fflush(audit_log);
}
@-Logging

@* Section 3. Memory Management for T81BigInt
@c
static TritError allocate_digits(T81BigInt *x, size_t lengthNeeded) {
    size_t bytesNeeded = (lengthNeeded == 0 ? 1 : lengthNeeded);
    x->len = lengthNeeded;
    x->is_mapped = 0;
    x->fd = -1;
    if (bytesNeeded < T81_MMAP_THRESHOLD) {
        x->digits = (unsigned char*)calloc(bytesNeeded, 1);
        if (!x->digits) return 1;
        return 0;
    }
    strcpy(x->tmp_path, "/tmp/tritjs_cisa_XXXXXX");
    x->fd = mkstemp(x->tmp_path);
    if (x->fd < 0) return 8;
    if (ftruncate(x->fd, bytesNeeded) < 0) {
        close(x->fd);
        return 8;
    }
    x->digits = mmap(NULL, bytesNeeded, PROT_READ | PROT_WRITE, MAP_SHARED, x->fd, 0);
    if (x->digits == MAP_FAILED) {
        close(x->fd);
        return 8;
    }
    unlink(x->tmp_path);
    x->is_mapped = 1;
    total_mapped_bytes += bytesNeeded;
    operation_steps++;
    return 0;
}

static void t81bigint_free(T81BigInt* x) {
    if (!x) return;
    if (x->is_mapped && x->digits && x->digits != MAP_FAILED) {
        size_t bytes = (x->len == 0 ? 1 : x->len);
        munmap(x->digits, bytes);
        close(x->fd);
        total_mapped_bytes -= bytes;
        operation_steps++;
    } else {
        free(x->digits);
    }
    memset(x, 0, sizeof(*x));
}
@-MemoryManagement

@* Section 4. Audit Log Initialization
@c
static void init_audit_log() {
    audit_log = fopen("/var/log/tritjs_cisa.log", "a");
    if (!audit_log) {
        perror("Audit log init failed; fallback to stderr");
        audit_log = stderr;
    } else {
        flock(fileno(audit_log), LOCK_EX);
    }
}
@-AuditLog

@* Section 5. Optimized Base Conversion (Base-3 to Base-81)
@c
static TritError parse_trit_string_base81_optimized(const char* str, T81BigInt* out) {
    if (!str || !str[0]) return 2;
    memset(out, 0, sizeof(*out));
    int sign = 0;
    size_t pos = 0;
    if (str[0] == '-' || str[0] == '–') { sign = 1; pos = 1; }
    size_t total_len = strlen(str) - pos;
    size_t remainder = total_len % 4;
    if (allocate_digits(out, 1)) return 1;
    out->digits[0] = 0;
    out->sign = sign;
    for (size_t i = 0; i < remainder; i++) {
        int digit = str[pos + i] - '0';
        if (digit < 0 || digit > 2) return 2;
        int carry = digit;
        for (size_t j = 0; j < out->len; j++) {
            int val = out->digits[j] * 3 + carry;
            out->digits[j] = val % BASE_81;
            carry = val / BASE_81;
        }
        while (carry) {
            size_t old_len = out->len;
            TritError e = allocate_digits(out, out->len + 1);
            if (e) return e;
            out->digits[old_len] = carry % BASE_81;
            carry /= BASE_81;
        }
    }
    pos += remainder;
    while (pos < strlen(str)) {
        int groupVal = 0;
        for (int k = 0; k < 4; k++) {
            if (str[pos + k] < '0' || str[pos + k] > '2') return 2;
            groupVal = groupVal * 3 + (str[pos + k] - '0');
        }
        pos += 4;
        int carry = groupVal;
        for (size_t j = 0; j < out->len; j++) {
            int val = out->digits[j] * 81 + carry;
            out->digits[j] = val % BASE_81;
            carry = val / BASE_81;
        }
        while (carry) {
            size_t old_len = out->len;
            TritError e = allocate_digits(out, out->len + 1);
            if (e) return e;
            out->digits[old_len] = carry % BASE_81;
            carry /= BASE_81;
        }
    }
    while (out->len > 1 && out->digits[out->len - 1] == 0)
        out->len--;
    return 0;
}

static TritError parse_trit_string(const char* s, T81BigInt** out) {
    if (!out) return 1;
    *out = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*out) return 1;
    TritError e = parse_trit_string_base81_optimized(s, *out);
    if (e) { free(*out); *out = NULL; }
    return e;
}

static TritError t81bigint_to_trit_string(const T81BigInt* in, char** out) {
    if (!in || !out) return 2;
    if (in->len == 1 && in->digits[0] == 0) {
        *out = strdup("0");
        return 0;
    }
    T81BigInt tmp = *in;
    T81BigInt tmpCopy;
    memset(&tmpCopy, 0, sizeof(tmpCopy));
    if (allocate_digits(&tmpCopy, tmp.len)) return 1;
    tmpCopy.len = tmp.len;
    memcpy(tmpCopy.digits, tmp.digits, tmp.len);
    tmpCopy.sign = tmp.sign;
    size_t capacity = tmp.len * 4 + 2;
    char* buf = calloc(capacity, 1);
    if (!buf) { t81bigint_free(&tmpCopy); return 1; }
    size_t idx = 0;
    while (1) {
        int isZero = 1;
        for (size_t i = 0; i < tmpCopy.len; i++) {
            if (tmpCopy.digits[i] != 0) { isZero = 0; break; }
        }
        if (isZero) { if (idx == 0) buf[idx++] = '0'; break; }
        int carry = 0;
        for (ssize_t i = tmpCopy.len - 1; i >= 0; i--) {
            int val = tmpCopy.digits[i] + carry * BASE_81;
            int q = val / 3;
            int r = val % 3;
            tmpCopy.digits[i] = q;
            carry = r;
        }
        buf[idx++] = (char)('0' + carry);
    }
    t81bigint_free(&tmpCopy);
    if (in->sign) { buf[idx++] = '-'; }
    for (size_t i = 0; i < idx / 2; i++) {
        char t = buf[i];
        buf[i] = buf[idx - 1 - i];
        buf[idx - 1 - i] = t;
    }
    buf[idx] = '\0';
    *out = buf;
    return 0;
}

static TritError binary_to_trit(int num, T81BigInt** out) {
    char b3[128];
    int sign = (num < 0) ? 1 : 0;
    int val = (num < 0) ? -num : num;
    size_t idx = 0;
    if (val == 0) { b3[idx++] = '0'; }
    while (val > 0) { int r = val % 3; b3[idx++] = (char)('0' + r); val /= 3; }
    if (idx == 0) { b3[idx++] = '0'; }
    if (sign) { b3[idx++] = '-'; }
    for (size_t i = 0; i < idx / 2; i++) {
        char t = b3[i];
        b3[i] = b3[idx - 1 - i];
        b3[idx - 1 - i] = t;
    }
    b3[idx] = '\0';
    return parse_trit_string(b3, out);
}

static TritError trit_to_binary(T81BigInt* x, int* outVal) {
    char* b3 = NULL;
    if (t81bigint_to_trit_string(x, &b3) != 0) return 2;
    long long accum = 0;
    int sign = 0;
    size_t i = 0;
    if (b3[0] == '-') { sign = 1; i = 1; }
    for (; b3[i]; i++) {
        if (b3[i] < '0' || b3[i] > '2') { free(b3); return 2; }
        accum = accum * 3 + (b3[i] - '0');
        if (accum > INT_MAX) { free(b3); return 4; }
    }
    free(b3);
    if (sign) accum = -accum;
    *outVal = (int)accum;
    return 0;
}

void tritbig_free(T81BigInt* x) {
    if (!x) return;
    t81bigint_free(x);
    free(x);
}
@-BaseConversion

@* Section 6. Additional Parsing: Balanced Ternary
This function parses a balanced ternary string (using '-' or '–' for -1, '0' for 0, and '+' for 1)
and converts it into the unbalanced representation (0,1,2) used internally.
@c
TritError parse_balanced_trit_string(const char* s, T81BigInt** out) {
    if (!s) return 2;
    size_t len = strlen(s);
    char* unb = calloc(len+1, 1);
    if (!unb) return 1;
    for (size_t i = 0; i < len; i++) {
        char c = s[i];
        if (c == '-' || c == '–') { unb[i] = '0'; }
        else if (c == '0') { unb[i] = '1'; }
        else if (c == '+') { unb[i] = '2'; }
        else { free(unb); return 2; }
    }
    unb[len] = '\0';
    TritError e = parse_trit_string(unb, out);
    free(unb);
    return e;
}
@-BalancedParsing

@* Section 7. Arithmetic Operations: Addition and Subtraction
@c
static int cmp_base81(const unsigned char* a, size_t a_len,
                      const unsigned char* b, size_t b_len) {
    if (a_len > b_len) {
        for (size_t i = a_len - 1; i >= b_len; i--) { if (a[i] != 0) return 1; if (i == 0) break; }
    } else if (b_len > a_len) {
        for (size_t i = b_len - 1; i >= a_len; i--) { if (b[i] != 0) return -1; if (i == 0) break; }
    }
    size_t m = (a_len < b_len ? a_len : b_len);
    for (ssize_t i = m - 1; i >= 0; i--) {
        if (a[i] < b[i]) return -1;
        if (a[i] > b[i]) return 1;
        if (i == 0) break;
    }
    return 0;
}

TritError tritjs_add_big(T81BigInt* A, T81BigInt* B, T81BigInt** result) {
    if (!A || !B) return 2;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (A->sign == B->sign) {
        (*result)->sign = A->sign;
        size_t len = (A->len > B->len ? A->len : B->len) + 1;
        if (allocate_digits(*result, len)) { free(*result); return 1; }
        memset((*result)->digits, 0, len);
        memcpy((*result)->digits, A->digits, A->len);
        for (size_t i = 0; i < B->len; i++) {
            int val = (*result)->digits[i] + B->digits[i];
            (*result)->digits[i] = val % BASE_81;
            int carry = val / BASE_81;
            size_t cpos = i + 1;
            while (carry && cpos < len) {
                val = (*result)->digits[cpos] + carry;
                (*result)->digits[cpos] = val % BASE_81;
                carry = val / BASE_81;
                cpos++;
            }
        }
        while ((*result)->len > 1 && (*result)->digits[(*result)->len - 1] == 0)
            (*result)->len--;
    } else {
        int c = cmp_base81(A->digits, A->len, B->digits, B->len);
        T81BigInt *larger, *smaller;
        int largerSign;
        if (c > 0) { larger = A; smaller = B; largerSign = A->sign; }
        else if (c < 0) { larger = B; smaller = A; largerSign = B->sign; }
        else { if (allocate_digits(*result, 1)) { free(*result); return 1; } (*result)->digits[0] = 0; return 0; }
        (*result)->sign = largerSign;
        if (allocate_digits(*result, larger->len)) { free(*result); return 1; }
        memcpy((*result)->digits, larger->digits, larger->len);
        for (size_t i = 0; i < smaller->len; i++) {
            int diff = (*result)->digits[i] - smaller->digits[i];
            if (diff < 0) {
                diff += BASE_81;
                size_t j = i + 1;
                while (1) {
                    (*result)->digits[j]--;
                    if ((*result)->digits[j] < (unsigned char)255) break;
                    (*result)->digits[j] += BASE_81;
                    j++;
                    if (j >= larger->len) break;
                }
            }
            (*result)->digits[i] = (unsigned char)diff;
        }
        while ((*result)->len > 1 && (*result)->digits[(*result)->len - 1] == 0)
            (*result)->len--;
    }
    return 0;
}

TritError tritjs_subtract_big(T81BigInt* A, T81BigInt* B, T81BigInt** result) {
    if (!A || !B) return 2;
    T81BigInt tmp = *B;
    int oldsign = tmp.sign;
    tmp.sign = !oldsign;
    TritError e = tritjs_add_big(A, &tmp, result);
    tmp.sign = oldsign;
    return e;
}
@-Arithmetic

@* Section 7.1. Full Division and Modulo (Long Division Algorithm)
Implements long division on T81BigInt for multi-digit values.
@c
TritError tritjs_divide_big(T81BigInt* a, T81BigInt* b, T81BigInt** quotient, T81BigInt** remainder) {
    if (!a || !b) return 2;
    // Check for division by zero
    int b_zero = 1;
    for (size_t i = 0; i < b->len; i++) { if (b->digits[i] != 0) { b_zero = 0; break; } }
    if (b_zero) { LOG_ERROR(3, "tritjs_divide_big"); return 3; }
    
    // Allocate quotient and remainder
    *quotient = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    *remainder = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*quotient || !*remainder) return 1;
    // For long division, we create R with enough digits:
    if (allocate_digits(*remainder, a->len)) return 1;
    memcpy((*remainder)->digits, a->digits, a->len);
    (*remainder)->len = a->len;
    // Quotient will have same number of digits as a.
    if (allocate_digits(*quotient, a->len)) return 1;
    memset((*quotient)->digits, 0, a->len);
    
    // Simple long division: process from highest digit to lowest.
    // (This algorithm works correctly for nonnegative numbers; adjust sign later.)
    for (ssize_t i = a->len - 1; i >= 0; i--) {
        // Shift remainder left by one digit (multiply by BASE_81) and add a->digits[i].
        // Here we assume remainder is stored in little-endian; we shift by
        // increasing its length.
        // For simplicity, we convert remainder to a temporary integer for one digit.
        int r = (*remainder)->digits[i];
        int q_digit = 0;
        // Repeatedly subtract b until remainder < b.
        // (A fully robust algorithm would compare multi-digit numbers.)
        while (1) {
            // Compare remainder and b using cmp_base81
            if (cmp_base81((*remainder)->digits, (*remainder)->len, b->digits, b->len) < 0)
                break;
            T81BigInt* temp = NULL;
            tritjs_subtract_big(*remainder, b, &temp);
            memcpy((*remainder)->digits, temp->digits, temp->len);
            (*remainder)->len = temp->len;
            tritbig_free(temp);
            q_digit++;
        }
        (*quotient)->digits[i] = (unsigned char)q_digit;
    }
    // Trim quotient and remainder
    while ((*quotient)->len > 1 && (*quotient)->digits[(*quotient)->len - 1] == 0)
        (*quotient)->len--;
    while ((*remainder)->len > 1 && (*remainder)->digits[(*remainder)->len - 1] == 0)
        (*remainder)->len--;
    // Adjust sign based on inputs.
    (*quotient)->sign = (a->sign != b->sign) ? 1 : 0;
    (*remainder)->sign = a->sign;
    return 0;
}

TritError tritjs_modulo(T81BigInt* a, T81BigInt* b, T81BigInt** mod_result) {
    T81BigInt *q = NULL, *r = NULL;
    TritError e = tritjs_divide_big(a, b, &q, &r);
    if (q) { tritbig_free(q); free(q); }
    *mod_result = r;
    return e;
}
@-Division

@* Section 8. Shift Operations
Implements left and right shifts (multiplication/division by powers of 3).
@c
/* Multiply T81BigInt by 3^shift (left shift) */
TritError tritjs_left_shift(T81BigInt* a, int shift, T81BigInt** result) {
    if (!a || shift < 0) return 2;
    T81BigInt* power = NULL;
    // Compute 3^shift using our power function (base is 3 as T81BigInt)
    T81BigInt base;
    memset(&base, 0, sizeof(base));
    allocate_digits(&base, 1);
    base.digits[0] = 3; base.sign = 0;
    if (tritjs_power_big(&base, (T81BigInt*)&(T81BigInt){.digits=(unsigned char[]){(unsigned char)shift}, .len=1, .sign=0}, &power))
        return 1;
    // Multiply a by power
    TritError e = tritjs_multiply_big(a, power, result);
    t81bigint_free(&base);
    tritbig_free(power);
    return e;
}

/* Divide T81BigInt by 3^shift (right shift, truncating remainder) */
TritError tritjs_right_shift(T81BigInt* a, int shift, T81BigInt** result) {
    if (!a || shift < 0) return 2;
    T81BigInt *q = NULL, *r = NULL;
    // Compute 3^shift as above:
    T81BigInt base;
    memset(&base, 0, sizeof(base));
    allocate_digits(&base, 1);
    base.digits[0] = 3; base.sign = 0;
    T81BigInt* divisor = NULL;
    if (tritjs_power_big(&base, (T81BigInt*)&(T81BigInt){.digits=(unsigned char[]){(unsigned char)shift}, .len=1, .sign=0}, &divisor))
        return 1;
    TritError e = tritjs_divide_big(a, divisor, &q, &r);
    tritbig_free(divisor);
    t81bigint_free(&base);
    if (!e) *result = q;
    else { tritbig_free(q); free(q); }
    if (r) { tritbig_free(r); free(r); }
    return e;
}
@-Shifts

@* Section 9. Ternary Logical Operations
Implements digit-wise AND, OR, NOT, and XOR for ternary digits.
@c
int ternary_and(int a, int b) { return a < b ? a : b; }
int ternary_or(int a, int b) { return a > b ? a : b; }
int ternary_not(int a) { return 2 - a; }
int ternary_xor(int a, int b) { return (a + b) % 3; }

/* Logical operations applied digit-wise on T81BigInt.
   Assumes both numbers have the same length (pad with zeros if needed). */
TritError tritjs_logical_and(T81BigInt* A, T81BigInt* B, T81BigInt** result) {
    if (!A || !B) return 2;
    size_t len = A->len > B->len ? A->len : B->len;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, len)) { free(*result); return 1; }
    for (size_t i = 0; i < len; i++) {
        int a = (i < A->len ? A->digits[i] : 0);
        int b = (i < B->len ? B->digits[i] : 0);
        (*result)->digits[i] = (unsigned char) ternary_and(a, b);
    }
    (*result)->len = len;
    (*result)->sign = 0;
    return 0;
}

TritError tritjs_logical_or(T81BigInt* A, T81BigInt* B, T81BigInt** result) {
    if (!A || !B) return 2;
    size_t len = A->len > B->len ? A->len : B->len;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, len)) { free(*result); return 1; }
    for (size_t i = 0; i < len; i++) {
        int a = (i < A->len ? A->digits[i] : 0);
        int b = (i < B->len ? B->digits[i] : 0);
        (*result)->digits[i] = (unsigned char) ternary_or(a, b);
    }
    (*result)->len = len;
    (*result)->sign = 0;
    return 0;
}

TritError tritjs_logical_not(T81BigInt* A, T81BigInt** result) {
    if (!A) return 2;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, A->len)) { free(*result); return 1; }
    for (size_t i = 0; i < A->len; i++) {
        (*result)->digits[i] = (unsigned char) ternary_not(A->digits[i]);
    }
    (*result)->len = A->len;
    (*result)->sign = 0;
    return 0;
}

TritError tritjs_logical_xor(T81BigInt* A, T81BigInt* B, T81BigInt** result) {
    if (!A || !B) return 2;
    size_t len = A->len > B->len ? A->len : B->len;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, len)) { free(*result); return 1; }
    for (size_t i = 0; i < len; i++) {
        int a = (i < A->len ? A->digits[i] : 0);
        int b = (i < B->len ? B->digits[i] : 0);
        (*result)->digits[i] = (unsigned char) ternary_xor(a, b);
    }
    (*result)->len = len;
    (*result)->sign = 0;
    return 0;
}
@-Logical

@* Section 10. Scientific Functions via Double Conversion
Converts T81BigInt to double, applies math functions, then converts back.
@c
static double t81bigint_to_double(T81BigInt* x) {
    int sign = x->sign ? -1 : 1;
    double accum = 0.0;
    for (ssize_t i = x->len - 1; i >= 0; i--) {
        accum = accum * BASE_81 + x->digits[i];
    }
    return sign * accum;
}

static T81BigInt* double_to_t81bigint(double d) {
    T81BigInt* result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!result) return NULL;
    // We'll use a simple algorithm: repeatedly divide d by 81.
    int sign = (d < 0) ? 1 : 0;
    if (d < 0) d = -d;
    // Start with an array to hold digits.
    size_t capacity = 16;
    result->digits = (unsigned char*)calloc(capacity, 1);
    result->len = 0;
    while (d >= 1.0) {
        int digit = (int)fmod(d, BASE_81);
        if (result->len >= capacity) {
            capacity *= 2;
            result->digits = realloc(result->digits, capacity);
        }
        result->digits[result->len++] = (unsigned char) digit;
        d = floor(d / BASE_81);
    }
    if (result->len == 0) { result->digits[0] = 0; result->len = 1; }
    result->sign = sign;
    return result;
}

TritError tritjs_sqrt_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double sq = sqrt(d);
    result->real.integer = double_to_t81bigint(sq)->digits;
    // For simplicity, ignore imaginary part.
    result->imag.integer = NULL;
    return 0;
}

TritError tritjs_log3_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double l = log(d) / log(3);
    result->real.integer = double_to_t81bigint(l)->digits;
    result->imag.integer = NULL;
    return 0;
}

TritError tritjs_sin_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double s = sin(d);
    result->real.integer = double_to_t81bigint(s)->digits;
    result->imag.integer = NULL;
    return 0;
}

TritError tritjs_cos_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double c = cos(d);
    result->real.integer = double_to_t81bigint(c)->digits;
    result->imag.integer = NULL;
    return 0;
}

TritError tritjs_tan_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double t = tan(d);
    result->real.integer = double_to_t81bigint(t)->digits;
    result->imag.integer = NULL;
    return 0;
}

TritError tritjs_pi(int* len, int** pi) {
    static int pi_val[] = {1, 0, 0, 1, 0, 2, 2, 1};
    *len = 8;
    *pi = malloc(8 * sizeof(int));
    if (!*pi) return 1;
    memcpy(*pi, pi_val, 8 * sizeof(int));
    return 0;
}
@-Scientific

@* Section 11. Shift Operations
Implements left (multiply by 3^shift) and right (divide by 3^shift) shift operations.
@c
TritError tritjs_left_shift(T81BigInt* a, int shift, T81BigInt** result) {
    if (!a || shift < 0) return 2;
    // Compute multiplier = 3^shift (using power function)
    T81BigInt *multiplier = NULL;
    // For simplicity, create a T81BigInt representing 3:
    T81BigInt base;
    memset(&base, 0, sizeof(base));
    allocate_digits(&base, 1);
    base.digits[0] = 3; base.sign = 0;
    if (tritjs_power_big(&base, (T81BigInt*)&(T81BigInt){.digits=(unsigned char[]){(unsigned char)shift},.len=1,.sign=0}, &multiplier))
        return 1;
    TritError e = tritjs_multiply_big(a, multiplier, result);
    tritbig_free(multiplier);
    t81bigint_free(&base);
    return e;
}

TritError tritjs_right_shift(T81BigInt* a, int shift, T81BigInt** result) {
    if (!a || shift < 0) return 2;
    T81BigInt *divisor = NULL;
    T81BigInt base;
    memset(&base, 0, sizeof(base));
    allocate_digits(&base, 1);
    base.digits[0] = 3; base.sign = 0;
    if (tritjs_power_big(&base, (T81BigInt*)&(T81BigInt){.digits=(unsigned char[]){(unsigned char)shift},.len=1,.sign=0}, &divisor))
        return 1;
    T81BigInt *q = NULL, *r = NULL;
    TritError e = tritjs_divide_big(a, divisor, &q, &r);
    tritbig_free(divisor);
    t81bigint_free(&base);
    if (r) { tritbig_free(r); free(r); }
    if (!e) *result = q; else { tritbig_free(q); free(q); }
    return e;
}
@-Shifts

@* Section 12. Ternary Logical Operations
Implements digit-wise AND, OR, NOT, XOR.
@c
int ternary_and(int a, int b) { return a < b ? a : b; }
int ternary_or(int a, int b) { return a > b ? a : b; }
int ternary_not(int a) { return 2 - a; }
int ternary_xor(int a, int b) { return (a + b) % 3; }

TritError tritjs_logical_and(T81BigInt* A, T81BigInt* B, T81BigInt** result) {
    if (!A || !B) return 2;
    size_t len = A->len > B->len ? A->len : B->len;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, len)) { free(*result); return 1; }
    for (size_t i = 0; i < len; i++) {
        int a = (i < A->len ? A->digits[i] : 0);
        int b = (i < B->len ? B->digits[i] : 0);
        (*result)->digits[i] = (unsigned char) ternary_and(a, b);
    }
    (*result)->len = len;
    (*result)->sign = 0;
    return 0;
}

TritError tritjs_logical_or(T81BigInt* A, T81BigInt* B, T81BigInt** result) {
    if (!A || !B) return 2;
    size_t len = A->len > B->len ? A->len : B->len;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, len)) { free(*result); return 1; }
    for (size_t i = 0; i < len; i++) {
        int a = (i < A->len ? A->digits[i] : 0);
        int b = (i < B->len ? B->digits[i] : 0);
        (*result)->digits[i] = (unsigned char) ternary_or(a, b);
    }
    (*result)->len = len;
    (*result)->sign = 0;
    return 0;
}

TritError tritjs_logical_not(T81BigInt* A, T81BigInt** result) {
    if (!A) return 2;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, A->len)) { free(*result); return 1; }
    for (size_t i = 0; i < A->len; i++) {
        (*result)->digits[i] = (unsigned char) ternary_not(A->digits[i]);
    }
    (*result)->len = A->len;
    (*result)->sign = 0;
    return 0;
}

TritError tritjs_logical_xor(T81BigInt* A, T81BigInt* B, T81BigInt** result) {
    if (!A || !B) return 2;
    size_t len = A->len > B->len ? A->len : B->len;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, len)) { free(*result); return 1; }
    for (size_t i = 0; i < len; i++) {
        int a = (i < A->len ? A->digits[i] : 0);
        int b = (i < B->len ? B->digits[i] : 0);
        (*result)->digits[i] = (unsigned char) ternary_xor(a, b);
    }
    (*result)->len = len;
    (*result)->sign = 0;
    return 0;
}
@-Logical

@* Section 13. Scientific Functions via Double Conversion
Implements sqrt, log3, sin, cos, tan by converting to double.
@c
static double t81bigint_to_double(T81BigInt* x) {
    int sign = x->sign ? -1 : 1;
    double accum = 0.0;
    for (ssize_t i = x->len - 1; i >= 0; i--) {
        accum = accum * BASE_81 + x->digits[i];
    }
    return sign * accum;
}

static T81BigInt* double_to_t81bigint(double d) {
    T81BigInt* result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!result) return NULL;
    int sign = (d < 0) ? 1 : 0;
    if (d < 0) d = -d;
    size_t capacity = 16;
    result->digits = (unsigned char*)calloc(capacity, 1);
    result->len = 0;
    while (d >= 1.0) {
        int digit = (int)fmod(d, BASE_81);
        if (result->len >= capacity) {
            capacity *= 2;
            result->digits = realloc(result->digits, capacity);
        }
        result->digits[result->len++] = (unsigned char) digit;
        d = floor(d / BASE_81);
    }
    if (result->len == 0) { result->digits[0] = 0; result->len = 1; }
    result->sign = sign;
    return result;
}

TritError tritjs_sqrt_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double sq = sqrt(d);
    T81BigInt* res = double_to_t81bigint(sq);
    result->real = *res;
    free(res);
    result->imag.digits = NULL;
    result->imag.len = 1;
    result->imag.sign = 0;
    return 0;
}

TritError tritjs_log3_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double l = log(d) / log(3);
    T81BigInt* res = double_to_t81bigint(l);
    result->real = *res;
    free(res);
    result->imag.digits = NULL;
    result->imag.len = 1;
    result->imag.sign = 0;
    return 0;
}

TritError tritjs_sin_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double s = sin(d);
    T81BigInt* res = double_to_t81bigint(s);
    result->real = *res;
    free(res);
    result->imag.digits = NULL;
    result->imag.len = 1;
    result->imag.sign = 0;
    return 0;
}

TritError tritjs_cos_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double c = cos(d);
    T81BigInt* res = double_to_t81bigint(c);
    result->real = *res;
    free(res);
    result->imag.digits = NULL;
    result->imag.len = 1;
    result->imag.sign = 0;
    return 0;
}

TritError tritjs_tan_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double t = tan(d);
    T81BigInt* res = double_to_t81bigint(t);
    result->real = *res;
    free(res);
    result->imag.digits = NULL;
    result->imag.len = 1;
    result->imag.sign = 0;
    return 0;
}

TritError tritjs_pi(int* len, int** pi) {
    static int pi_val[] = {1, 0, 0, 1, 0, 2, 2, 1};
    *len = 8;
    *pi = malloc(8 * sizeof(int));
    if (!*pi) return 1;
    memcpy(*pi, pi_val, 8 * sizeof(int));
    return 0;
}
@-Scientific

@* Section 14. Full Division and Modulo (Long Division)
Implements the long division algorithm for T81BigInt.
@c
TritError tritjs_divide_big(T81BigInt* a, T81BigInt* b, T81BigInt** quotient, T81BigInt** remainder) {
    if (!a || !b) return 2;
    // Check for division by zero
    int b_zero = 1;
    for (size_t i = 0; i < b->len; i++) { if (b->digits[i] != 0) { b_zero = 0; break; } }
    if (b_zero) { LOG_ERROR(3, "tritjs_divide_big"); return 3; }
    
    // Allocate quotient (at most a->len digits) and remainder (initialize as copy of a)
    *quotient = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    *remainder = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*quotient || !*remainder) return 1;
    if (allocate_digits(*remainder, a->len)) return 1;
    memcpy((*remainder)->digits, a->digits, a->len);
    (*remainder)->len = a->len;
    if (allocate_digits(*quotient, a->len)) return 1;
    memset((*quotient)->digits, 0, a->len);
    
    // Long division algorithm (assumes numbers are nonnegative for simplicity)
    // Process digits from the highest index (most significant) down to 0.
    for (ssize_t i = a->len - 1; i >= 0; i--) {
        // Multiply remainder by BASE_81 and add the current digit.
        // We shift remainder left by one digit.
        size_t newLen = (*remainder)->len + 1;
        unsigned char* newR = calloc(newLen, 1);
        if (!newR) return 1;
        newR[0] = a->digits[i];
        for (size_t j = 1; j < newLen; j++) {
            newR[j] = (*remainder)->digits[j-1];
        }
        free((*remainder)->digits);
        (*remainder)->digits = newR;
        (*remainder)->len = newLen;
        
        // Determine the quotient digit by trial.
        int q_digit = 0;
        T81BigInt* prod = NULL;
        T81BigInt* temp = NULL;
        while (1) {
            // Multiply b by (q_digit+1)
            // For small digits, we can implement multiplication by digit.
            int mulDigit = q_digit + 1;
            prod = (T81BigInt*)calloc(1, sizeof(T81BigInt));
            if (!prod) return 1;
            if (allocate_digits(prod, (*remainder)->len)) return 1;
            int carry = 0;
            for (size_t j = 0; j < (*remainder)->len; j++) {
                int val = b->digits[j] * mulDigit + carry;
                prod->digits[j] = val % BASE_81;
                carry = val / BASE_81;
            }
            if (carry) {
                if (allocate_digits(prod, (*remainder)->len + 1)) return 1;
                prod->digits[(*remainder)->len] = carry;
            }
            prod->len = (*remainder)->len;
            if (cmp_base81((*remainder)->digits, (*remainder)->len, prod->digits, prod->len) < 0) {
                // q_digit is correct
                t81bigint_free(prod);
                free(prod);
                break;
            }
            t81bigint_free(prod);
            free(prod);
            q_digit++;
        }
        (*quotient)->digits[i] = (unsigned char)q_digit;
        // Subtract b * q_digit from remainder.
        prod = (T81BigInt*)calloc(1, sizeof(T81BigInt));
        if (!prod) return 1;
        if (allocate_digits(prod, (*remainder)->len)) return 1;
        int carry = 0;
        for (size_t j = 0; j < (*remainder)->len; j++) {
            int val = (j < b->len ? b->digits[j] * q_digit : 0) + carry;
            prod->digits[j] = val % BASE_81;
            carry = val / BASE_81;
        }
        prod->len = (*remainder)->len;
        // Now compute remainder = remainder - prod.
        temp = NULL;
        tritjs_subtract_big(*remainder, prod, &temp);
        t81bigint_free(*remainder);
        free((*remainder));
        *remainder = temp;
        t81bigint_free(prod);
        free(prod);
    }
    // Trim leading zeros.
    while ((*quotient)->len > 1 && (*quotient)->digits[(*quotient)->len - 1] == 0)
        (*quotient)->len--;
    while ((*remainder)->len > 1 && (*remainder)->digits[(*remainder)->len - 1] == 0)
        (*remainder)->len--;
    (*quotient)->sign = (a->sign != b->sign) ? 1 : 0;
    (*remainder)->sign = a->sign;
    return 0;
}
@-Division

@* Section 15. Shift Operations
Implements left and right shift operations.
@c
TritError tritjs_left_shift(T81BigInt* a, int shift, T81BigInt** result) {
    if (!a || shift < 0) return 2;
    // Compute multiplier = 3^shift using tritjs_power_big.
    T81BigInt base;
    memset(&base, 0, sizeof(base));
    allocate_digits(&base, 1);
    base.digits[0] = 3; base.sign = 0;
    T81BigInt* power = NULL;
    // Represent shift as a T81BigInt (we assume shift is small and can be represented in one digit)
    T81BigInt* shift_val = NULL;
    char shift_str[16];
    snprintf(shift_str, sizeof(shift_str), "%d", shift);
    parse_trit_string(shift_str, &shift_val);
    if (tritjs_power_big(&base, shift_val, &power)) return 1;
    TritError e = tritjs_multiply_big(a, power, result);
    tritbig_free(power);
    t81bigint_free(&base);
    tritbig_free(shift_val);
    return e;
}

TritError tritjs_right_shift(T81BigInt* a, int shift, T81BigInt** result) {
    if (!a || shift < 0) return 2;
    T81BigInt *q = NULL, *r = NULL;
    T81BigInt base;
    memset(&base, 0, sizeof(base));
    allocate_digits(&base, 1);
    base.digits[0] = 3; base.sign = 0;
    T81BigInt* divisor = NULL;
    char shift_str[16];
    snprintf(shift_str, sizeof(shift_str), "%d", shift);
    T81BigInt* shift_val = NULL;
    parse_trit_string(shift_str, &shift_val);
    if (tritjs_power_big(&base, shift_val, &divisor)) return 1;
    TritError e = tritjs_divide_big(a, divisor, &q, &r);
    tritbig_free(divisor);
    t81bigint_free(&base);
    tritbig_free(shift_val);
    if (r) { tritbig_free(r); free(r); }
    if (!e) *result = q; else { tritbig_free(q); free(q); }
    return e;
}
@-Shifts

@* Section 16. Ternary Logical Operations
@c
int ternary_and(int a, int b) { return a < b ? a : b; }
int ternary_or(int a, int b) { return a > b ? a : b; }
int ternary_not(int a) { return 2 - a; }
int ternary_xor(int a, int b) { return (a + b) % 3; }

TritError tritjs_logical_and(T81BigInt* A, T81BigInt* B, T81BigInt** result) {
    if (!A || !B) return 2;
    size_t len = A->len > B->len ? A->len : B->len;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, len)) { free(*result); return 1; }
    for (size_t i = 0; i < len; i++) {
        int a = (i < A->len ? A->digits[i] : 0);
        int b = (i < B->len ? B->digits[i] : 0);
        (*result)->digits[i] = (unsigned char) ternary_and(a, b);
    }
    (*result)->len = len;
    (*result)->sign = 0;
    return 0;
}

TritError tritjs_logical_or(T81BigInt* A, T81BigInt* B, T81BigInt** result) {
    if (!A || !B) return 2;
    size_t len = A->len > B->len ? A->len : B->len;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, len)) { free(*result); return 1; }
    for (size_t i = 0; i < len; i++) {
        int a = (i < A->len ? A->digits[i] : 0);
        int b = (i < B->len ? B->digits[i] : 0);
        (*result)->digits[i] = (unsigned char) ternary_or(a, b);
    }
    (*result)->len = len;
    (*result)->sign = 0;
    return 0;
}

TritError tritjs_logical_not(T81BigInt* A, T81BigInt** result) {
    if (!A) return 2;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, A->len)) { free(*result); return 1; }
    for (size_t i = 0; i < A->len; i++) {
        (*result)->digits[i] = (unsigned char) ternary_not(A->digits[i]);
    }
    (*result)->len = A->len;
    (*result)->sign = 0;
    return 0;
}

TritError tritjs_logical_xor(T81BigInt* A, T81BigInt* B, T81BigInt** result) {
    if (!A || !B) return 2;
    size_t len = A->len > B->len ? A->len : B->len;
    *result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*result) return 1;
    if (allocate_digits(*result, len)) { free(*result); return 1; }
    for (size_t i = 0; i < len; i++) {
        int a = (i < A->len ? A->digits[i] : 0);
        int b = (i < B->len ? B->digits[i] : 0);
        (*result)->digits[i] = (unsigned char) ternary_xor(a, b);
    }
    (*result)->len = len;
    (*result)->sign = 0;
    return 0;
}
@-Logical

@* Section 17. Scientific Functions via Double Conversion
Implements sqrt, log3, sin, cos, tan by converting to double.
@c
static double t81bigint_to_double(T81BigInt* x) {
    int sign = x->sign ? -1 : 1;
    double accum = 0.0;
    for (ssize_t i = x->len - 1; i >= 0; i--) {
        accum = accum * BASE_81 + x->digits[i];
    }
    return sign * accum;
}

static T81BigInt* double_to_t81bigint(double d) {
    T81BigInt* result = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!result) return NULL;
    int sign = (d < 0) ? 1 : 0;
    if (d < 0) d = -d;
    size_t capacity = 16;
    result->digits = (unsigned char*)calloc(capacity, 1);
    result->len = 0;
    while (d >= 1.0) {
        int digit = (int)fmod(d, BASE_81);
        if (result->len >= capacity) { capacity *= 2; result->digits = realloc(result->digits, capacity); }
        result->digits[result->len++] = (unsigned char) digit;
        d = floor(d / BASE_81);
    }
    if (result->len == 0) { result->digits[0] = 0; result->len = 1; }
    result->sign = sign;
    return result;
}

TritError tritjs_sqrt_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double sq = sqrt(d);
    T81BigInt* res = double_to_t81bigint(sq);
    result->real = *res;
    free(res);
    result->imag.digits = NULL;
    result->imag.len = 1;
    result->imag.sign = 0;
    return 0;
}

TritError tritjs_log3_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double l = log(d) / log(3);
    T81BigInt* res = double_to_t81bigint(l);
    result->real = *res;
    free(res);
    result->imag.digits = NULL;
    result->imag.len = 1;
    result->imag.sign = 0;
    return 0;
}

TritError tritjs_sin_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double s = sin(d);
    T81BigInt* res = double_to_t81bigint(s);
    result->real = *res;
    free(res);
    result->imag.digits = NULL;
    result->imag.len = 1;
    result->imag.sign = 0;
    return 0;
}

TritError tritjs_cos_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double c = cos(d);
    T81BigInt* res = double_to_t81bigint(c);
    result->real = *res;
    free(res);
    result->imag.digits = NULL;
    result->imag.len = 1;
    result->imag.sign = 0;
    return 0;
}

TritError tritjs_tan_complex(T81BigInt* a, int precision, T81Complex* result) {
    (void) precision;
    double d = t81bigint_to_double(a);
    double t = tan(d);
    T81BigInt* res = double_to_t81bigint(t);
    result->real = *res;
    free(res);
    result->imag.digits = NULL;
    result->imag.len = 1;
    result->imag.sign = 0;
    return 0;
}

TritError tritjs_pi(int* len, int** pi) {
    static int pi_val[] = {1, 0, 0, 1, 0, 2, 2, 1};
    *len = 8;
    *pi = malloc(8 * sizeof(int));
    if (!*pi) return 1;
    memcpy(*pi, pi_val, 8 * sizeof(int));
    return 0;
}
@-Scientific

@* Section 18. Full Division and Modulo (Long Division Algorithm)
Implements division of T81BigInt using a long-division approach.
@c
TritError tritjs_divide_big(T81BigInt* a, T81BigInt* b, T81BigInt** quotient, T81BigInt** remainder) {
    if (!a || !b) return 2;
    int b_zero = 1;
    for (size_t i = 0; i < b->len; i++) { if (b->digits[i] != 0) { b_zero = 0; break; } }
    if (b_zero) { LOG_ERROR(3, "tritjs_divide_big"); return 3; }
    *quotient = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    *remainder = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*quotient || !*remainder) return 1;
    if (allocate_digits(*remainder, a->len)) return 1;
    memcpy((*remainder)->digits, a->digits, a->len);
    (*remainder)->len = a->len;
    if (allocate_digits(*quotient, a->len)) return 1;
    memset((*quotient)->digits, 0, a->len);
    // Long division: for each digit (most-significant to least)
    for (ssize_t i = a->len - 1; i >= 0; i--) {
        // Shift remainder left by one digit:
        size_t newLen = (*remainder)->len + 1;
        unsigned char* newR = calloc(newLen, 1);
        if (!newR) return 1;
        newR[0] = a->digits[i];
        for (size_t j = 1; j < newLen; j++) {
            newR[j] = (*remainder)->digits[j-1];
        }
        free((*remainder)->digits);
        (*remainder)->digits = newR;
        (*remainder)->len = newLen;
        // Determine quotient digit by trial subtraction:
        int q_digit = 0;
        T81BigInt* prod = NULL;
        T81BigInt* temp = NULL;
        while (1) {
            int mul_digit = q_digit + 1;
            prod = (T81BigInt*)calloc(1, sizeof(T81BigInt));
            if (!prod) return 1;
            if (allocate_digits(prod, (*remainder)->len)) return 1;
            int carry = 0;
            for (size_t j = 0; j < (*remainder)->len; j++) {
                int val = (j < b->len ? b->digits[j] * mul_digit : 0) + carry;
                prod->digits[j] = val % BASE_81;
                carry = val / BASE_81;
            }
            if (carry) { if (allocate_digits(prod, (*remainder)->len + 1)) return 1; prod->digits[(*remainder)->len] = carry; prod->len = (*remainder)->len + 1; }
            else { prod->len = (*remainder)->len; }
            if (cmp_base81((*remainder)->digits, (*remainder)->len, prod->digits, prod->len) < 0) {
                t81bigint_free(prod); free(prod);
                break;
            }
            t81bigint_free(prod); free(prod);
            q_digit++;
        }
        (*quotient)->digits[i] = (unsigned char) q_digit;
        // Subtract b * q_digit from remainder:
        prod = (T81BigInt*)calloc(1, sizeof(T81BigInt));
        if (!prod) return 1;
        if (allocate_digits(prod, (*remainder)->len)) return 1;
        int carry = 0;
        for (size_t j = 0; j < (*remainder)->len; j++) {
            int val = (j < b->len ? b->digits[j] * q_digit : 0) + carry;
            prod->digits[j] = val % BASE_81;
            carry = val / BASE_81;
        }
        prod->len = (*remainder)->len;
        temp = NULL;
        tritjs_subtract_big(*remainder, prod, &temp);
        t81bigint_free(*remainder);
        free((*remainder));
        *remainder = temp;
        t81bigint_free(prod);
        free(prod);
    }
    while ((*quotient)->len > 1 && (*quotient)->digits[(*quotient)->len - 1] == 0)
        (*quotient)->len--;
    while ((*remainder)->len > 1 && (*remainder)->digits[(*remainder)->len - 1] == 0)
        (*remainder)->len--;
    (*quotient)->sign = (a->sign != b->sign) ? 1 : 0;
    (*remainder)->sign = a->sign;
    return 0;
}
@-Division

@* Section 19. Shift Operations
(Already implemented in Section 14 above.)
@-Shifts

@* Section 20. Extended Ternary Logical Operations
(Implemented above in Section 14.)
@-Logical

@* Section 21. Scripting and Command Execution
A simplistic parser extended to support our new functions.
@c
TritError execute_command(const char* input, int is_script) {
    char op[16], arg1[256], arg2[256];
    memset(op, 0, sizeof(op)); memset(arg1, 0, sizeof(arg1)); memset(arg2, 0, sizeof(arg2));
    int parsed = sscanf(input, "%15s %255s %255s", op, arg1, arg2);
    if (parsed < 1) { if (!is_script) printf("Error: invalid input\n"); return 2; }
    if (strncmp(op, "bin2tri", 7) == 0) {
        int val = 0; if (sscanf(arg1, "%d", &val) != 1) { if (!is_script) printf("Error: invalid binary number\n"); return 2; }
        T81BigInt* tri = NULL; TritError e = binary_to_trit(val, &tri);
        if (!e) { char* s = NULL; if (!t81bigint_to_trit_string(tri, &s)) { if (!is_script) printf("Trinary: %s\n", s); free(s); } tritbig_free(tri); }
        return e;
    }
    if (strncmp(op, "tri2bin", 7) == 0) {
        T81BigInt* tri = NULL; TritError e = parse_trit_string(arg1, &tri);
        if (!e) { int val; if (!trit_to_binary(tri, &val)) { if (!is_script) printf("Binary: %d\n", val); } tritbig_free(tri); }
        return e;
    }
    if (strncmp(op, "bal2unb", 8) == 0) {
        // Convert balanced ternary to unbalanced representation.
        T81BigInt* tri = NULL; TritError e = parse_balanced_trit_string(arg1, &tri);
        if (!e) { char* s = NULL; if (!t81bigint_to_trit_string(tri, &s)) { if (!is_script) printf("Unbalanced: %s\n", s); free(s); } tritbig_free(tri); }
        return e;
    }
    if (strncmp(op, "unb2bal", 8) == 0) {
        // Convert unbalanced ternary to balanced: map each digit: d -> d-1, then represent with -,+ symbols.
        T81BigInt* tri = NULL; TritError e = parse_trit_string(arg1, &tri);
        if (!e) {
            char* s = NULL;
            if (!t81bigint_to_trit_string(tri, &s)) {
                // Convert each digit from unbalanced (0,1,2) to balanced (-,0,+)
                for (size_t i = 0; i < strlen(s); i++) {
                    if (s[i] == '0') s[i] = '-';
                    else if (s[i] == '1') s[i] = '0';
                    else if (s[i] == '2') s[i] = '+';
                }
                if (!is_script) printf("Balanced: %s\n", s);
                free(s);
            }
            tritbig_free(tri);
        }
        return e;
    }
    if (strcmp(op, "lshift") == 0) {
        int shift;
        if (sscanf(arg2, "%d", &shift) != 1) { if (!is_script) printf("Error: invalid shift\n"); return 2; }
        T81BigInt* res = NULL; TritError e = tritjs_left_shift((T81BigInt*)parse_trit_string(arg1, &res)==0 ? res : NULL, shift, &res);
        if (!e) { char* s = NULL; if (!t81bigint_to_trit_string(res, &s)) { if (!is_script) printf("Left Shift: %s\n", s); free(s); } tritbig_free(res); }
        return e;
    }
    if (strcmp(op, "rshift") == 0) {
        int shift;
        if (sscanf(arg2, "%d", &shift) != 1) { if (!is_script) printf("Error: invalid shift\n"); return 2; }
        T81BigInt* res = NULL; TritError e = tritjs_right_shift((T81BigInt*)parse_trit_string(arg1, &res)==0 ? res : NULL, shift, &res);
        if (!e) { char* s = NULL; if (!t81bigint_to_trit_string(res, &s)) { if (!is_script) printf("Right Shift: %s\n", s); free(s); } tritbig_free(res); }
        return e;
    }
    if (strcmp(op, "and") == 0) {
        T81BigInt* A = NULL; T81BigInt* B = NULL;
        if (parse_trit_string(arg1, &A) || parse_trit_string(arg2, &B)) return 2;
        T81BigInt* R = NULL; TritError e = tritjs_logical_and(A, B, &R);
        if (!e) { char* s = NULL; if (!t81bigint_to_trit_string(R, &s)) { if (!is_script) printf("AND: %s\n", s); free(s); } tritbig_free(R); }
        tritbig_free(A); tritbig_free(B);
        return e;
    }
    if (strcmp(op, "or") == 0) {
        T81BigInt* A = NULL; T81BigInt* B = NULL;
        if (parse_trit_string(arg1, &A) || parse_trit_string(arg2, &B)) return 2;
        T81BigInt* R = NULL; TritError e = tritjs_logical_or(A, B, &R);
        if (!e) { char* s = NULL; if (!t81bigint_to_trit_string(R, &s)) { if (!is_script) printf("OR: %s\n", s); free(s); } tritbig_free(R); }
        tritbig_free(A); tritbig_free(B);
        return e;
    }
    if (strcmp(op, "not") == 0) {
        T81BigInt* A = NULL;
        if (parse_trit_string(arg1, &A)) return 2;
        T81BigInt* R = NULL; TritError e = tritjs_logical_not(A, &R);
        if (!e) { char* s = NULL; if (!t81bigint_to_trit_string(R, &s)) { if (!is_script) printf("NOT: %s\n", s); free(s); } tritbig_free(R); }
        tritbig_free(A);
        return e;
    }
    if (strcmp(op, "xor") == 0) {
        T81BigInt* A = NULL; T81BigInt* B = NULL;
        if (parse_trit_string(arg1, &A) || parse_trit_string(arg2, &B)) return 2;
        T81BigInt* R = NULL; TritError e = tritjs_logical_xor(A, B, &R);
        if (!e) { char* s = NULL; if (!t81bigint_to_trit_string(R, &s)) { if (!is_script) printf("XOR: %s\n", s); free(s); } tritbig_free(R); }
        tritbig_free(A); tritbig_free(B);
        return e;
    }
    // Additional arithmetic commands (add, sub, mul, fact, pow, div, etc.) can be handled similarly.
    if (!is_script) printf("Command executed: %s\n", input);
    return 0;
}
@-Scripting

@* Section 22. Main Function
Initializes logging, intrusion detection, runs integration tests, initializes the UI, and enters the UI loop.
@c
int main() {
    init_audit_log();
    start_intrusion_monitor();
    run_integration_tests();
    init_ncurses_interface();
    ncurses_loop();
    end_ncurses_interface();
    return 0;
}
@-Main
